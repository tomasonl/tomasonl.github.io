<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>ZJRC工作记录 | 李响的博客中心</title><meta name="keywords" content="工作记录"><meta name="author" content="Tomasonlee"><meta name="copyright" content="Tomasonlee"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="Redis健康检查SpringBoot监控Actuator，关闭redis监测当我们导入了spring-boot-starter-actuator这个依赖后, SpringBoot会默认去监测一些信息。其中就包括redis、 会根据redis的默认初始配置， localhost:6379 尝试连接redis。如果我们没有用到redis， 启动就会报错 &lt;dependency&gt;">
<meta property="og:type" content="article">
<meta property="og:title" content="ZJRC工作记录">
<meta property="og:url" content="http://tomasonl.github.io/2021/06/18/ZJRC%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="李响的博客中心">
<meta property="og:description" content="Redis健康检查SpringBoot监控Actuator，关闭redis监测当我们导入了spring-boot-starter-actuator这个依赖后, SpringBoot会默认去监测一些信息。其中就包括redis、 会根据redis的默认初始配置， localhost:6379 尝试连接redis。如果我们没有用到redis， 启动就会报错 &lt;dependency&gt;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ns-strategy.cdn.bcebos.com/ns-strategy/upload/fc_big_pic/part-00161-3058.jpg">
<meta property="article:published_time" content="2021-06-18T09:03:19.000Z">
<meta property="article:modified_time" content="2021-07-14T11:06:00.267Z">
<meta property="article:author" content="Tomasonlee">
<meta property="article:tag" content="工作记录">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ns-strategy.cdn.bcebos.com/ns-strategy/upload/fc_big_pic/part-00161-3058.jpg"><link rel="shortcut icon" href="/img/1.jpg"><link rel="canonical" href="http://tomasonl.github.io/2021/06/18/ZJRC%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-14 19:06:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="李响的博客中心" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时光印记</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签浏览</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 游乐中心</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/photo/"><i class="fa-fw fas fa-images"></i><span> 时光照相馆</span></a></li><li><a class="site-page" href="/movie/"><i class="fa-fw fas fa-video"></i><span> 影音娱乐室</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 指南中心</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于作者</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://ns-strategy.cdn.bcebos.com/ns-strategy/upload/fc_big_pic/part-00161-3058.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">李响的博客中心</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时光印记</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签浏览</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 游乐中心</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/photo/"><i class="fa-fw fas fa-images"></i><span> 时光照相馆</span></a></li><li><a class="site-page" href="/movie/"><i class="fa-fw fas fa-video"></i><span> 影音娱乐室</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 指南中心</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于作者</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">ZJRC工作记录</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-18T09:03:19.000Z" title="发表于 2021-06-18 17:03:19">2021-06-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-14T11:06:00.267Z" title="更新于 2021-07-14 19:06:00">2021-07-14</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Redis健康检查"><a href="#Redis健康检查" class="headerlink" title="Redis健康检查"></a>Redis健康检查</h1><p>SpringBoot监控Actuator，关闭redis监测<br>当我们导入了spring-boot-starter-actuator这个依赖后, SpringBoot会默认去监测一些信息。其中就包括redis、 会根据redis的默认初始配置， localhost:6379 尝试连接redis。如果我们没有用到redis， 启动就会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.2.1.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p>启动会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[WARN ] 2020-05-28 09:28:17.179 [registrationTask1] de.codecentric.boot.admin.client.registration.ApplicationRegistrator - Failed to register application as Application(name&#x3D;admin-client, managementUrl&#x3D;http:&#x2F;&#x2F;Gordon-pc:8768&#x2F;actuator, healthUrl&#x3D;http:&#x2F;&#x2F;Gordon-pc:8768&#x2F;actuator&#x2F;health, serviceUrl&#x3D;http:&#x2F;&#x2F;Gordon-pc:8768&#x2F;) at spring-boot-admin ([http:&#x2F;&#x2F;localhost:8769&#x2F;instances]): I&#x2F;O error on POST request for &quot;http:&#x2F;&#x2F;localhost:8769&#x2F;instances&quot;: Connection refused: connect; nested exception is java.net.ConnectException: Connection refused: connect. Further attempts are logged on DEBUG level</span><br><span class="line">[WARN ] 2020-05-28 09:28:19.075 [boundedElastic-1] org.springframework.boot.actuate.redis.RedisReactiveHealthIndicator - Redis health check failed</span><br><span class="line">org.springframework.data.redis.RedisConnectionFailureException: Unable to connect to Redis; nested exception is io.lettuce.core.RedisConnectionException: Unable to connect to localhost:6379</span><br><span class="line">	at org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory$SharedConnection.getNativeConnection(LettuceConnectionFactory.java:1200)</span><br><span class="line">	at org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory$SharedConnection.getConnection(LettuceConnectionFactory.java:1179)</span><br><span class="line">	at org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory.getSharedReactiveConnection(LettuceConnectionFactory.java:952)</span><br></pre></td></tr></table></figure>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul>
<li>Bean<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component(&quot;redisHealthIndicator&quot;)</span><br><span class="line">public class RedisHealthIndicator implements HealthIndicator &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Health health() &#123;</span><br><span class="line">        return Health.up().build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">management:</span><br><span class="line">  health:</span><br><span class="line">    redis:</span><br><span class="line">      enabled: false</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="类型转换问题"><a href="#类型转换问题" class="headerlink" title="类型转换问题"></a>类型转换问题</h1><p>如果是有符号的 Bigint(20) 取值范围是-9223372036854775808~9223372036854775807，与 Java中的java.lang.Long的取值范围是一致的，而如果是无符号的Bigint(20),其取值范围是0 ~ 18446744073709551615，其中一般超出了Long的取值范围，会被映射为BigInteger。</p>
<h1 id="java-sql-SQLFeatureNotSupportedException"><a href="#java-sql-SQLFeatureNotSupportedException" class="headerlink" title="java.sql.SQLFeatureNotSupportedException"></a>java.sql.SQLFeatureNotSupportedException</h1><p>3.1.0之前版本没问题，针对3.1.1以及后续版本出现上述问题</p>
<p>现象： 集成druid数据源，使用3.1.0之前版本没问题，升级mp到3.1.1+后，运行时报错:java.sql.SQLFeatureNotSupportedException</p>
<p>原因： mybatis plus 3.1.1+使用了新版jdbc，LocalDateTime等新日期类型处理方式升级，但druid在1.1.21版本之前不支持<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy95WTlteWZDUGdTNzRkUGtlNzlpYW50djN4WjV1RUpvanpOV0VjaWFEMVdMUnNYVXNwd242bU5XdlRvaWFiNU9UNm80NzVNY050bGliNjRWelBscmlheHlpYUpwZy82NDA?x-oss-process=image/format,png"><br>解决方案： 1. 升级druid到1.1.21及其以上，解决这个问题</p>
<p>2.将mybatis-plus的版本降至3.2.0或以下</p>
<p>3.将LocalDateTime类型更换成Date</p>
<p>4.添加pom依赖（推荐）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-typehandlers-jsr310&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h1 id="在Java代码规范中为什么不能出现System-out-println"><a href="#在Java代码规范中为什么不能出现System-out-println" class="headerlink" title="在Java代码规范中为什么不能出现System.out.println()"></a>在Java代码规范中为什么不能出现System.out.println()</h1><p>初学者一般在开发中或者调试bug的时候，都会习惯性的使用System.out.println语句，输出到控制台中，观察数据是否正常。开发或者调试完毕，很可能就忘记删除，直接就发布到生产中去了。</p>
<p>写了测试代码，循环10w次的打印时间需要耗时408毫秒，没有打印的循环几乎等于0毫秒。<br>原理分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void println(String x) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从System.out.println的源代码，我们可以看到它在一开始就用synchronized同步锁给锁起来了，所以System.out.println是一个同步方法，在高并发的情况下，会严重影响性能。<br>总结<br>在日常开发或者调试的过程中，尽量使用log4j2或者logback这些异步的方法，进行日志的统一收集，禁止使用System.out.println。项目上线前也要进行全局搜索，防止有人误提交带有System.out.println的代码。</p>
<h1 id="MybatisPlus更新返回值问题"><a href="#MybatisPlus更新返回值问题" class="headerlink" title="MybatisPlus更新返回值问题"></a>MybatisPlus更新返回值问题</h1><p>update 返回值代表什么呢？默认情况下，mybatis 的 update 操作的返回值是 matched 匹配条数的记录数，并不是受影响的记录数。<br>设置update返回为受影响条数<br>通过对 JDBC URL 显式的指定 useAffectedRows 选项（通常就在jdbc url配置的最后加上下面这段就OK了）<br>jdbc:mysql://${jdbc.host}/${jdbc.db}?useAffectedRows=true</p>
<h1 id="用-Autowired-还是-Resource-对比-总结"><a href="#用-Autowired-还是-Resource-对比-总结" class="headerlink" title="用@Autowired 还是@Resource(对比+总结)"></a>用@Autowired 还是@Resource(对比+总结)</h1><p>当使用@Autowired注入的时候, UserServiceImpl 上面只需要这样写 @Service，这样就会自动找到UserService这个类型以及他的子类型。UserServiceImpl 实现了UserService，所以能够找到它。不过这样有一个缺点，就是当UserService实现类有两个以上的时候，这个时候会找哪一个呢，这就造成了冲突，所以,要用@Autowired注入的时候要确保UserService只有一个实现类。</p>
<p>@Resource（这个注解属于J2EE的），默认按照名称进行装配，名称可以通过name属性进行指定， 如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。 当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</p>
<p>有人可能会想了，这下好了，用这个是万能的了，不用管名字了，也不用管类型了，但这里还是有缺点。首先，根据这个注解的匹配效果可以看出，它进行了两次匹配，也就是说，如果你在UserServiceImpl这个类上面写@Service,它会怎么找呢？<br>首先是找相同名字的，如果没有找到，再找相同类型的，而这里的@Service没有写名字，这个时候就进行了两次搜索，显然，速度就下降了许多。<br>也许你还会问，这里的@Service本来就没有名字，肯定是直接进行类型搜索啊。其实不是这样的，UserServiceImpl 类上面如果有@Service，默认的名字是userServiceImpl，就是把类名前面的大写变成小写，就是默认的Bean的名字了。<br>@Resource根据名字搜索是这样写的:@Resource(“userService”)，如果你写了这个名字叫userService，那么UserServiceImpl上面必须也写@Service(“userService”)，不然还是会报错。</p>
<p>@Autowired @Qualifier(“userService”) 是直接按照名字进行搜索，也就是说，对于UserServiceImpl 上面@Service注解必须写名字，不写就会报错，而且名字必须与@Autowired @Qualifier(“userService”) 保持一致，即必须写:@service(“userService”)。如果@Service上面写了名字，而@Autowired @Qualifier() 这样写，一样会报错。</p>
<p>如果你的架构设计师考虑的比较精细，要求比较严格，要求项目上线后的访问速度比较好，通常是考虑速度了。这个时候@Autowired没有@Resource好用，因为@Resource可以根据名字来搜索，是这样写的@Resource(“userService”)。这个@Autowired @Qualifier(“userService”) 也可以用名字啊，为什么不用呢，原因很简单，这个有点长，不喜欢，增加工作量。因为根据名字搜索是最快的，就好像查数据库一样，根据Id查找最快。因为这里的名字与数据库里面的ID是一样的作用。这个时候，就要求你多写几个名字，工作量自然就增加了。而如果你不用注解，用xml文件的时候，对于注入Bean的时候要求写一个Id，xml文件时候的id就相当于这里的名字。</p>
<p>@Resource的作用相当于@Autowired，只不过@Autowired按byType自动注入，而@Resource默认按 byName自动注入罢了。@Resource有两个属性是比较重要的，分别是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。</p>
<h2 id="Resource装配顺序"><a href="#Resource装配顺序" class="headerlink" title="@Resource装配顺序"></a>@Resource装配顺序</h2><p>　　1. 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常<br>　　2. 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常<br>　　3. 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常<br>　　4. 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配</p>
<p>终极方案:</p>
<p>简洁但不保证性能:UserServiceImpl上面写@Service装配用@Resource.其配置过程:@Service默认名字为:类名首字母小写:userServiceImpl,</p>
<p>@Autowired按类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false。如果查询的结果不止一个，那么@Autowired会根据名称来查找。如果我们想使用按名称装配，也可以结合@Qualifier注解一起使用。</p>
<p>@Resource有两个中重要的属性：name和type。name属性指定byName，如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。需要注意的是，@Resource如果没有指定name属性，并且按照默认的名称仍然找不到依赖对象时， @Resource注解会回退到按类型装配。但一旦指定了name属性，就只能按名称装配了。</p>
<h1 id="静态注入"><a href="#静态注入" class="headerlink" title="静态注入"></a>静态注入</h1><p>Spring中使用@Autowired注解静态实例对象<br>最近项目小组在重新规划工程的业务缓存，其中涉及到部分代码重构，过程中发现有些工具类中的静态方法需要依赖别的对象实例（该实例已配置在xml成Spring bean，非静态可以用@Autowired加载正常使用），而我们知道，类加载后静态成员是在内存的共享区，静态方法里面的变量必然要使用静态成员变量，这就有了如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class TestClass &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private static AutowiredTypeComponent component;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 调用静态组件的方法</span><br><span class="line">    public static void testMethod() &#123;</span><br><span class="line">        component.callTestMethod()；</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译正常，但运行时报java.lang.NullPointerException: null异常，显然在调用testMethod()方法时，component变量还没被初始化，报NPE。</p>
<p>原因<br>所以，在Springframework里，我们是不能@Autowired一个静态变量，使之成为一个Spring bean的。为什么？其实很简单，因为当类加载器加载静态变量时，Spring上下文尚未加载。所以类加载器不会在bean中正确注入静态类，并且会失败。</p>
<p>解决方案<br>方式一<br>将@Autowired 注解到类的构造函数上。很好理解，Spring扫描到AutowiredTypeComponent的bean，然后赋给静态变量component。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class TestClass &#123;</span><br><span class="line"></span><br><span class="line">    private static AutowiredTypeComponent component;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public TestClass(AutowiredTypeComponent component) &#123;</span><br><span class="line">        TestClass.component &#x3D; component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 调用静态组件的方法</span><br><span class="line">    public static void testMethod() &#123;</span><br><span class="line">        component.callTestMethod()；</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方式二<br>给静态组件加setter方法，并在这个方法上加上@Autowired。Spring能扫描到AutowiredTypeComponent的bean，然后通过setter方法注入。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class TestClass &#123;</span><br><span class="line"></span><br><span class="line">    private static AutowiredTypeComponent component;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setComponent(AutowiredTypeComponent component)&#123;</span><br><span class="line">        TestClass.component &#x3D; component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 调用静态组件的方法</span><br><span class="line">    public static void testMethod() &#123;</span><br><span class="line">        component.callTestMethod()；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方式三<br>定义一个静态组件，定义一个非静态组件并加上@Autowired注解，再定义一个初始化组件的方法并加上@PostConstruct注解。这个注解是JavaEE引入的，作用于servlet生命周期的注解，你只需要知道，用它注解的方法在构造函数之后就会被调用。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class TestClass &#123;</span><br><span class="line"></span><br><span class="line">   private static AutowiredTypeComponent component;</span><br><span class="line"></span><br><span class="line">   @Autowired</span><br><span class="line">   private AutowiredTypeComponent autowiredComponent;</span><br><span class="line"></span><br><span class="line">   @PostConstruct</span><br><span class="line">   private void beforeInit() &#123;</span><br><span class="line">      component &#x3D; this.autowiredComponent;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 调用静态组件的方法</span><br><span class="line">   public static void testMethod() &#123;</span><br><span class="line">      component.callTestMethod();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>方式四<br>直接用Spring框架工具类获取bean，定义成局部变量使用。但有弊端：如果该类中有多个静态方法多次用到这个组件则每次都要这样获取，个人不推荐这种方式。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestClass &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 调用静态组件的方法</span><br><span class="line">   public static void testMethod() &#123;</span><br><span class="line">      AutowiredTypeComponent component &#x3D; SpringApplicationContextUtil.getBean(&quot;component&quot;);</span><br><span class="line">      component.callTestMethod();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>总结<br>在上面的代码示例中，我每个类都加了@Component注解，其实可以根据需要进行变更，比如这个类是处理业务逻辑，可以换成@Service；这个类是处理请求进行转发或重定向的，可以换成@Controller（是Spring-mvc的注解）；这个类是专门用来操作Dao的就@Repository。Spring的注解帮你做了一件很有意义的事：就是它们对应用进行了分层，这样就能将请求处理、业务逻辑处理、数据库操作处理分离出来，为代码解耦，也方便了项目的开发和维护。</p>
<p>Spring容器bean加载机制用到了Java的反射，这里先不作赘述，以后会专门写一篇文章来总结Java反射在Spring的IoC和AoP中的应用。</p>
<h1 id="Optional-ofNullable-方法"><a href="#Optional-ofNullable-方法" class="headerlink" title="Optional.ofNullable()方法"></a>Optional.ofNullable()方法</h1><p>工作中经常会遇到，查询返回空，如果没有判空处理，一不小心就会空指针异常。加上if判断处理可以解决；<br>但是jdk1.8有更优雅的处理方式。</p>
<p>public static void main(String[] args) {<br>        List<String> list = null;<br>        List<String> newList = Optional.ofNullable(list).orElse(Lists.newArrayList());<br>        newList.forEach(x -&gt; System.out.println(x));<br>    }<br>先解释代码含义：如果list集合不为空，将list集合赋值给newList；如果list集合为空创建一个空对象集合赋值给newList，保证list集合永远不为空，也就避免了空指针异常。（为了更好的理解，分开写了，比较庸俗，实际工作中都是一行搞定，哈哈哈）</p>
<p>再看看源码：底层是怎么处理的，怎么就避免了空指针呢？</p>
<p>//静态变量 empty<br>private static final Optional&lt;?&gt; EMPTY = new Optional&lt;&gt;();</p>
<p>//如果对象为空，执行empty()方法；不为空，执行of(value)方法<br>public static <T> Optional<T> ofNullable(T value) {<br>        return value == null ? empty() : of(value);<br>    }</p>
<p>public static<T> Optional<T> empty() {<br>        @SuppressWarnings(“unchecked”)<br>        Optional<T> t = (Optional<T>) EMPTY;<br>        return t;<br>    }</p>
<p>public static <T> Optional<T> of(T value) {<br>        return new Optional&lt;&gt;(value);<br>    }<br>1.首先执行ofNullable()方法，如果T对象为空，执行empty()方法；不为空，执行of(value)方法；<br>2.empty()方法，初始化一个空对象Optional(空对象和null不是一回事哈)；</p>
<p>3.of(value)方法，将泛型对象T用于Optional构造方法的参数上，返回一个有值的对象</p>
<p>4.经过上面两步，从而保证了Optional不为null，避免了空指针；<br>————————————————</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/tomasonl?tab=repositories">秋实先生</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://tomasonl.github.io">https://tomasonl.github.io</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">此文章版权归属Tomasonl秋实先生所有，如有转载请注明出处</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/">工作记录</a></div><div class="post_share"><div class="social-share" data-image="https://ns-strategy.cdn.bcebos.com/ns-strategy/upload/fc_big_pic/part-00161-3058.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/WechatPay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/WechatPay.jpg"/></a><div class="post-qr-code-desc"></div></li><li class="reward-item"><a href="/img/Alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/Alipay.jpg"/></a><div class="post-qr-code-desc"></div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/06/30/EasyExcel/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">EasyExcel</div></div></a></div><div class="next-post pull-right"><a href="/2021/05/24/Confluence/"><img class="next-cover" src="https://pic2.zhimg.com/v2-f0533ec9d53e5306d7931d95302bf009_1440w.jpg?source=172ae18b" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Confluence</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/06/30/EasyExcel/" title="EasyExcel"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-30</div><div class="title">EasyExcel</div></div></a></div><div><a href="/2020/12/09/ElasticSearch分布式搜索分析引擎/" title="ElasticSearch分布式搜索分析引擎-A"><img class="cover" src="https://images.contentstack.io/v3/assets/bltefdd0b53724fa2ce/blt280217a63b82a734/5bbdaacf63ed239936a7dd56/elastic-logo.svg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-09</div><div class="title">ElasticSearch分布式搜索分析引擎-A</div></div></a></div><div><a href="/2020/12/19/ElasticSearch分布式搜索分析引擎-B/" title="ElasticSearch分布式搜索分析引擎-B"><img class="cover" src="https://images.contentstack.io/v3/assets/bltefdd0b53724fa2ce/blt280217a63b82a734/5bbdaacf63ed239936a7dd56/elastic-logo.svg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-19</div><div class="title">ElasticSearch分布式搜索分析引擎-B</div></div></a></div><div><a href="/2020/04/06/Java多线程/" title="JAVA多线程"><img class="cover" src="http://pic1.win4000.com/wallpaper/2020-11-18/5fb4d3232459a.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-06</div><div class="title">JAVA多线程</div></div></a></div><div><a href="/2021/03/04/Java开发-规范起来1/" title="Java日常开发-规范起来1"><img class="cover" src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1832317564,3433131942&fm=26&gp=0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-04</div><div class="title">Java日常开发-规范起来1</div></div></a></div><div><a href="/2021/03/09/Java开发-规范起来2/" title="Java开发-规范起来2"><img class="cover" src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1832317564,3433131942&fm=26&gp=0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-09</div><div class="title">Java开发-规范起来2</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Tomasonlee</div><div class="author-info__description">厚积薄发，行胜于言</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/tomasonl"><i class="fab fa-github"></i><span>关注一波 O(∩_∩)O</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/tomasonl" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://tomasonl.cloudstudio.net/dashboard/workspace" target="_blank" title="CloudStudio"><i class="fas fa-cloud"></i></a><a class="social-icon" href="https://gitee.com/tomasonl" target="_blank" title="Gitee"><i class="fab fa-git-square"></i></a></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5"><span class="toc-number">1.</span> <span class="toc-text">Redis健康检查</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">解决方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">类型转换问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java-sql-SQLFeatureNotSupportedException"><span class="toc-number">3.</span> <span class="toc-text">java.sql.SQLFeatureNotSupportedException</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8Java%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%87%BA%E7%8E%B0System-out-println"><span class="toc-number">4.</span> <span class="toc-text">在Java代码规范中为什么不能出现System.out.println()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MybatisPlus%E6%9B%B4%E6%96%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E9%97%AE%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">MybatisPlus更新返回值问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8-Autowired-%E8%BF%98%E6%98%AF-Resource-%E5%AF%B9%E6%AF%94-%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">用@Autowired 还是@Resource(对比+总结)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Resource%E8%A3%85%E9%85%8D%E9%A1%BA%E5%BA%8F"><span class="toc-number">6.1.</span> <span class="toc-text">@Resource装配顺序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%B3%A8%E5%85%A5"><span class="toc-number">7.</span> <span class="toc-text">静态注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Optional-ofNullable-%E6%96%B9%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">Optional.ofNullable()方法</span></a></li></ol></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Tomasonlee</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">厚积薄发，行胜于言！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>