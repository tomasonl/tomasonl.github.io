<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李响的技术博客</title>
  
  
  <link href="http://tomasonl.github.io/atom.xml" rel="self"/>
  
  <link href="http://tomasonl.github.io/"/>
  <updated>2020-12-05T03:00:47.391Z</updated>
  <id>http://tomasonl.github.io/</id>
  
  <author>
    <name>Tomasonlee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SM2国密算法-学习札记</title>
    <link href="http://tomasonl.github.io/2020/12/05/SM2%E5%9B%BD%E5%AF%86%E7%AE%97%E6%B3%95-%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/"/>
    <id>http://tomasonl.github.io/2020/12/05/SM2%E5%9B%BD%E5%AF%86%E7%AE%97%E6%B3%95-%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/</id>
    <published>2020-12-05T02:56:59.000Z</published>
    <updated>2020-12-05T03:00:47.391Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>国密算法是我国自主研发创新的一套数据加密处理系列算法。从SM1-SM4分别实现了对称、非对称、摘要等算法功能。特别适合应用于嵌入式物联网等相关领域，完成身份认证和数据加解密等功能。当然，默认的前提条件是算法密钥必须保证安全性，因此要将国密算法嵌入到硬件加密芯片中结合使用。</p><h1 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h1><p>国密即国家密码局认定的国产密码算法。主要有SM1，SM2，SM3，SM4。密钥长度和分组长度均为128位。</p><ul><li>SM1 为对称加密。其加密强度与AES相当。该算法不公开，调用该算法时，需要通过加密芯片的接口进行调用。</li><li>SM2为非对称加密，基于ECC。该算法已公开。由于该算法基于ECC，故其签名速度与秘钥生成速度都快于RSA。ECC 256位（SM2采用的就是ECC 256位的一种）安全强度比RSA 2048位高，但运算速度快于RSA。</li><li>SM3 消息摘要。可以用MD5作为对比理解。该算法已公开。校验结果为256位。</li><li>SM4 无线局域网标准的分组数据算法。对称加密，密钥长度和分组长度均为128位。<br>由于SM1、SM4加解密的分组大小为128bit，故对消息进行加解密时，若消息长度过长，需要进行分组，要消息长度不足，则要进行填充。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="工作记录" scheme="http://tomasonl.github.io/tags/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>分布式微服务治理</title>
    <link href="http://tomasonl.github.io/2020/12/02/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    <id>http://tomasonl.github.io/2020/12/02/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/</id>
    <published>2020-12-02T08:29:32.000Z</published>
    <updated>2020-12-05T01:27:18.373Z</updated>
    
    <content type="html"><![CDATA[<p><strong>微服务</strong>——一种软开技术，面向服务SOA架构的一种变体，把程序构造为很多松耦合的服务。<br><strong>分布式</strong>——一种部署方式，提高系统稳定性，优化性能。<br>分散部署在不同的机器。是一种面向SOA架构的，服务之间也是通过RPC等方式交互的。逻辑架构设计完后就该做物理架构设计，系统应用部署在超过一台服务器或虚拟机上，且各分开部署的部分彼此通过各种通讯协议交互信息，就可算作分布式部署，生产环境下的微服务肯定是分布式部署的，分布式部署的应用不一定是微服务架构的，比如集群部署，它是把相同应用复制到不同服务器上，但是逻辑功能上还是单体应用。</p><h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="1、微服务设计原则"><a href="#1、微服务设计原则" class="headerlink" title="1、微服务设计原则"></a>1、微服务设计原则</h2><ul><li>单一职责—-每个微服务只需实现自己的业务逻辑；</li><li>服务自治—-每个微服务从开发、测试、运维、存储等均独立,不依赖于其它模块;</li><li>轻量级通信—-通信的语言轻量,通信方式需跨语言、跨平台的；</li><li>接口明确—-接口尽量做的更通用,更灵活,从而尽量避免其它模块连带调整。</li></ul><h2 id="2、微服务四个核心问题："><a href="#2、微服务四个核心问题：" class="headerlink" title="2、微服务四个核心问题："></a>2、微服务四个核心问题：</h2><ul><li>这么多服务，客户端如何访问？</li><li>这么多服务，服务间如何通信？</li><li>这么多服务，如何实现和治理？</li><li>这么多服务，服务挂了怎么办？</li></ul><h2 id="3、微服务的优缺点？"><a href="#3、微服务的优缺点？" class="headerlink" title="3、微服务的优缺点？"></a>3、微服务的优缺点？</h2><ul><li>单一职责，聚焦指定业务功能，开发效率高；</li><li>松耦合，各阶段独立、存储可以独立也可以统一；</li><li>易于与第三方平台集成，自动部署（jenkins、Hudson、bamboo…）；</li><li>开发人员要处理分布式系统的复杂性、运维测试成本增大；</li><li>服务器通信成本，部署依赖问题，内存开销大；</li></ul><h2 id="4、微服务通信方式"><a href="#4、微服务通信方式" class="headerlink" title="4、微服务通信方式"></a>4、微服务通信方式</h2><h3 id="1、RPC通信介绍"><a href="#1、RPC通信介绍" class="headerlink" title="1、RPC通信介绍"></a>1、RPC通信介绍</h3><p>   RPC（Remote Procedure Call Protocol）远程过程调用，要从一台计算机上执行另外一台计算机上的程序。跨越了物理服务器的限制，在网络中完成。基于Socket，工作在会话层。自定义数据格式，速度快，效率高。</p><p>1、两个重点：能否快速建立连接、序列化和反序列化机制快不快；<br>2、框架很多：Dubbo、HSF、早期的webservice、谷歌开源的gRPC、Apache的Thrift、新浪微博的Montan等；</p><p>RPC调用过程<br><strong>序列化：</strong>把对象转换为字节序列的过程称为对象的序列化，编码过程。<br><strong>反序列化：</strong>把字节序列恢复为对象的过程称为对象的反序列化，也解码过程。</p><h3 id="2、HTTP通信介绍"><a href="#2、HTTP通信介绍" class="headerlink" title="2、HTTP通信介绍"></a>2、HTTP通信介绍</h3><p>http其实是一种网络传输协议，基于TCP，工作在应用层，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议，也可以用来进行远程服务调用。缺点是消息封装臃肿，优势是对服务的提供和调用方没有任何技术限定，自由灵活，更符合微服务理念。开源http客户端工具，例如：HttpClient（Apache）-OKHttp（android轻量网络通信框架,移动支付Square公司贡献(还提供Picasso图片缓存框架)，okhttp用于替代HttpUrlConnection和Apache HttpClient)-URLConnection（URLConnection任何网络连接都需要经过socket才能连接，HttpURLConnection不需要设置socket，所以，HttpURLConnection并不是底层的连接，而是在底层连接上的一个请求。这就是为什么HttpURLConneciton只是一个抽象类，自身不能被实例化的原因。）</p><p>Spring提供了一种简单便捷的模板—RestTemplate。底层是HttpURLConnection实现！使用restTemplate访问restful接口非常的简单粗暴无脑。(url、requestMap、ResponseBean.class)这三个参数分别代表 请求地址、请求参数、HTTP响应转换被转换成的对象类型。RestTemplate方法的名称遵循命名约定，第一部分指出正在调用什么HTTP方法，第二部分指示返回的内容。本例中调用了restTemplate.postForObject方法，post指调用了HTTP的post方法，Object指将HTTP响应转换为您选择的对象类型。</p><p>小结：</p><p>1.调用的各种实现所谓的http连接的api(包括java自带的httpurlconnection)其底层基本上都是调用的jdk的socket接口。<br>2.socket是基于tcp/ip协议封装的一套实现tcp连接的接口，或者说是工具。<br>3.所以会说其实http也是通过socket来实现的这种看似没有问题但又含糊不清的说法。<br>4.http只是一种协议，什么请求头，请求题，响应头都是根据固定的格式制定的报文，然后最终(可能不直接调用volley,okhttp等)都会通过socket接口将这些报文发给服务器或者客户端。</p><h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><p>SpringCloud是个生态，并不是一门技术。六大模块：负载均衡、服务注册与发现、监控、配置管理、网关、分布式追踪；</p><h2 id="1、Eureka注册中心"><a href="#1、Eureka注册中心" class="headerlink" title="1、Eureka注册中心"></a>1、Eureka注册中心</h2><p>首先我们来解决第一问题，服务的管理。犹瑞卡，注册中心来自NetFlix。<br>Eureka负责管理、记录服务提供者的信息。服务调像下单一样吧需求告诉Eureka，Eureka就会告诉所需服务。同时，服务提供方与Eureka之间通过 “心跳” 机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。这就实现了服务的自动注册、发现、状态监控。</p><p>Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址<br>提供者：启动后向Eureka注册自己信息（地址，提供什么服务）<br>消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新<br>心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态<br>1，启动器依赖<br>        <dependency><br>            <groupId>org.springframework.cloud</groupId><br>            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId><br>        </dependency><br>2，配置文件<br>server:<br>  port: 10086<br>spring:<br>  application:<br>    name: eureka-server<br>eureka:<br>  client:<br>    service-url:<br>      # eureka 服务地址，如果是集群的话；需要指定其它集群eureka地址<br>      defaultZone: <a href="http://127.0.0.1:10086/eureka">http://127.0.0.1:10086/eureka</a><br>    # 不注册自己，集群的话就注册<br>    register-with-eureka: false<br>    # 不拉取服务<br>    fetch-registry: false<br>3，服务注册与发现<br>服务注册：在服务提供工程user-service上添加Eureka客户端依赖；自动将服务注册到EurekaServer服务地址列表。<br>Provider启动时，会检测配置属性中的： eureka.client.register-with-erueka=true 参数是否正确，默认true。会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，EurekaServer会把这些信息保存到一个双层Map结构中。<br>第一层Map的Key—服务id，一般是配置中的 spring.application.name 属性<br>第二层Map的key—服务实例id。一般host+ serviceId + port，例如： localhost:user-service:8081<br>值则是服务的实例对象，也就是说一个服务，可以同时启动多个不同实例，形成集群。<br>服务发现：在服务消费工程consumer-demo上添加Eureka客户端依赖；可以使用工具类根据服务名称获取对应的服务地址列表。<br>添加Eureka客户端依赖<br>        <dependency><br>            <groupId>org.springframework.cloud</groupId><br>            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId><br>        </dependency><br>添加启动引导类注解<br>启动类加入@EnableDiscoveryClient 注解<br>修改配置<br>spring:<br>  application:<br>    name: consumer-demo（两个服务的名字）<br>eureka:<br>  client:<br>    service-url:<br>      defaultZone: <a href="http://127.0.0.1:10086/eureka%EF%BC%88Eureka%E4%B8%AD%E5%BF%83%E5%9C%B0%E5%9D%80%EF%BC%89">http://127.0.0.1:10086/eureka（Eureka中心地址）</a><br>4，Eureka高可用<br>eureka-server</p><p>eureka:<br>  server:<br>    # 服务失效剔除时间间隔，默认60秒<br>    eviction-interval-timer-in-ms: 60000<br>    # 关闭自我保护模式（默认是打开的）<br>    enable-self-preservation: false<br>user-service </p><p>eureka:<br>  client:<br>    service-url:<br>      defaultZone: <a href="http://127.0.0.1:10086/eureka">http://127.0.0.1:10086/eureka</a><br>  instance:<br>    # 更倾向使用ip地址，而不是host名<br>    prefer-ip-address: true<br>    # ip地址<br>    ip-address: 127.0.0.1<br>    # 续约间隔，默认30秒<br>    lease-renewal-interval-in-seconds: 5<br>    # 服务失效时间，默认90秒<br>    lease-expiration-duration-in-seconds: 5<br>consumer-demo </p><p>eureka:<br>  client:<br>    service-url:<br>      defaultZone: <a href="http://127.0.0.1:10086/eureka">http://127.0.0.1:10086/eureka</a><br>    # 获取服务地址列表间隔时间，默认30秒<br>    registry-fetch-interval-seconds: 10<br>5，Eureka失效剔除以及自我保护<br>默认注册时使用的是主机名或者localhost，如果想用ip进行注册，可以在 user-service 中添加配置如下：<br>prefer-ip-address: true # 更倾向于使用ip，而不是host名。</p><p>服务续约<br>注册服务完成以后，提供者会维持一个心跳（定时向EurekaServer发起Rest请求），告诉EurekaServer：“我还活着”。这个我们称为服务的续约（renew）；<br>lease-expiration-duration-in-seconds: 90 90秒没报告，中心可能会判定服务死了。😁provider<br>lease-renewal-interval-in-seconds: 30 间隔30秒报告自己还活着。🙂provider<br>eureka.server.eviction-interval-timer-in-ms： 中心定时移除已经挂了的提供者。😭server—-失效剔除<br>registry-fetch-interval-seconds: 30 服务消费者每隔30秒拉取中心当前服务列表。🤔 consumer</p><p>自我保护<br>我们关停一个服务，很可能会在Eureka面板警告，触发了Eureka的自我保护机制。<br>当服务未按时进行心跳续约时，Eureka会统计服务实例最近15分钟心跳续约的比例是否低于了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka在这段时间内不会剔除任何服务实例，直到网络恢复正常。生产环境下这很有效，保证了大多数服务依然可用，不过也有可能获取到失败的服务实例，因此服务调用者必须做好服务的失败容错。<br>可以通过下面的配置来关停自我保护：</p><p>enable-self-preservation: false # 关闭自我保护模式（默认打开）</p><h2 id="2、Ribbon负载均衡"><a href="#2、Ribbon负载均衡" class="headerlink" title="2、Ribbon负载均衡"></a>2、Ribbon负载均衡</h2><p>同属Netflix，使用负载均衡算法，例如轮询、随机或者自定义等算法,自动帮消费者在服务列表选择服务。默认轮询策略。在实例化RestTemplate的时候使用@LoadBalanced，服务地址直接可以使用服务名。</p><p>负载均衡器有三大组件：<br>1.负载规则 ,从服务器列表中决定用哪个服务器<br>2.ping任务,后台运行的任务，用来验证服务器是否可用<br>3.服务器列表,可以是静态也可以是动态，如果是动态，那么就要有一个后台线程定时去刷新和过滤列表。</p><p>均衡策略：</p><pre><code>@Beanpublic IRule ribbonRule() &#123;    return new RetryRule(new BestAvailableRule());//这里配置策略，和配置文件对应&#125;</code></pre><p>RoundRobinRule：轮询。默认超过10次获取到的server都不可用，会返回一个空的server<br>RandomRule：随机，如果随机到的server为null或者不可用的话，会while不停的循环选取<br>RetryRule：一定时限内循环重试。默认继承RoundRobinRule，也支持自定义注入，RetryRule会在每次选取之后，对选举的server进行判断，是否为null，是否alive，并且在500ms内会不停的选取判断。而RoundRobinRule失效的策略是超过10次，RandomRule是没有失效时间的概念，只要serverList没都挂。<br>BestAvailableRule：最小连接数。遍历serverList，选取出可用的且连接数最小的一个server。该算法里面有一个LoadBalancerStats的成员变量，会存储所有server的运行状况和连接数。如果选取到的server为null，那么会调用RoundRobinRule重新选取。<br>WeightedResponseTimeRule：最小响应时间。这个策略整合了随机算法和响应时间加权算法。会开启定时任务，每30秒计算一次所有Provider的响应时间，以响应时间作为权重，响应时间越短的服务器被选中的概率越大。<br>比如Node1:node2:node3的平均响应时间为100ms：200ms:300ms，那么nodes的的权重值是300:500:600，每次以600为基础*随机值，那么落在 0–300的概率为50%，300–500的概率33%，100–600的概率为17%，也就是平均响应时间越短的节点，被选中的概率越大<br>    double totalResponseTime = 0;<br>    //遍历获取所有节点的总的平均响应时间<br>    for (Server server : nlb.getAllServers()) {<br>        ServerStats ss = stats.getSingleServerStat(server);<br>        totalResponseTime += ss.getResponseTimeAvg();<br>    }<br>    Double weightSoFar = 0.0;<br>    //然后从第一个节点开始设置自增的weightSoFar，每个结点的权重值weight为总响应时间-自己的相应时间，也就是说，node的响应时间越短，weight的值就越大，就越有可能被随机数命中<br>    List<Double> finalWeights = new ArrayList<Double>();<br>    for (Server server : nlb.getAllServers()) {<br>        ServerStats ss = stats.getSingleServerStat(server);<br>        double weight = totalResponseTime - ss.getResponseTimeAvg();<br>        weightSoFar += weight;<br>        finalWeights.add(weightSoFar);<br>    }<br>    setWeights(finalWeights);</p><h2 id="3、hystrix服务熔断"><a href="#3、hystrix服务熔断" class="headerlink" title="3、hystrix服务熔断"></a>3、hystrix服务熔断</h2><p>海思锤科斯—哈哈，同属Netglix。Hystrix是一个延迟和容错库，用于隔离访问远程服务，防止出现级联失败。</p><p>Hystrix解决雪崩问题的手段主要是</p><p>1.服务降级:就是在雪崩情况下,防止用户一直等待,使用服务降级方式(返回一个友好的提示给客户端,不会去处理请求,调用fallBack本地方法),目的是为了客户的体验.<br>2.服务熔断:服务熔断是为了保护服务,假设服务最高并发10000,设置9000并发，超过就开启保护机制,使用服务降级改善体验,服务降级和服务熔断是一起使用的.<br>3.服务隔离:隔离分为线程池隔离和信号量隔离线程池隔离就是在重要的几个接口上都配置一个独立的线程池,它们之间互不影响,从而缓解雪崩效应.</p><p>服务隔离：用户请求不直接访问服务，而是使用线程池中空闲的线程访问服务，加速失败判断时间。<br>服务降级和熔断：及时返回服务调用失败的结果，让线程不因为等待服务而阻塞。线程池满或者请求超时—触发。</p><p>1，添加依赖</p><p>        <dependency></p><p>            <groupId>org.springframework.cloud</groupId></p><p>            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId></p><p>        </dependency></p><p>2，开启熔断</p><p>在启动类 ConsumerApplication 上添加注解：@EnableCircuitBreaker<br>至此，@SpringBootApplication+@EnableDiscoveryClient+@EnableCirciuitBreaker<br>经常引入这三个注解，Spring提供了@SpringCloudApplication的组合注解代替。</p><p>-3，降级逻辑</p><p>@RestController<br>@RequestMapping(“/consumer”)<br>@Slf4j<br>@DefaultProperties(defaultFallback = “defaultFallback”)</p><p>public class ConsumerController {<br>    @Autowired<br>    private RestTemplate restTemplate;<br>    @Autowired<br>    private DiscoveryClient discoveryClient;</p><p>    @GetMapping(“/{id}”)</p><p>    //@HystrixCommand(fallbackMethod = “queryByIdFallback”)<br>    @HystrixCommand</p><p>    public String queryById(@PathVariable Long id){<br>        /<em>String url = “<a href="http://localhost:9091/user/&quot;+id">http://localhost:9091/user/&quot;+id</a>;<br>      <br>        //获取eureka中注册的user-service的实例<br>        List<ServiceInstance> serviceInstances = discoveryClient.getInstances(“user-service”);<br>        ServiceInstance serviceInstance = serviceInstances.get(0);<br>        url = “http://“ + serviceInstance.getHost() + “:” + serviceInstance.getPort() + “/user/“ + id;</em>/</p><p>        String url = “<a href="http://user-service/user/&quot;">http://user-service/user/&quot;</a> + id;<br>        return restTemplate.getForObject(url, String.class);<br>    }</p><p>    public String queryByIdFallback(Long id){<br>        log.error(“查询用户信息失败。id：{}”, id);<br>        return “对不起，网络太拥挤了！”;<br>    }</p><p>    public String defaultFallback(){<br>        return “默认提示：对不起，网络太拥挤了！”;<br>    }</p><p>}<br>4，修改超时配置</p><p>hystrix:<br>  command:<br>    default:<br>      execution:<br>        isolation:<br>          thread:<br>            timeoutInMilliseconds: 2000<br>Hystrix的服务熔断机制，可以实现弹性容错；当服务请求情况好转之后，可以自动重连。通过断路的方式，将后续请求直接拒绝，一段时间（默认5秒）之后允许部分请求通过，如果调用成功则回到断路器关闭状态，否则继续打开，拒绝请求的服务。</p><h1 id="配置修改熔断策略："><a href="#配置修改熔断策略：" class="headerlink" title="配置修改熔断策略："></a>配置修改熔断策略：</h1><p>hystrix:<br>command:<br> default:<br>  circuitBreaker:<br>   errorThresholdPercentage: 50 # 触发熔断错误比例阈值，默认值50%<br>   sleepWindowInMilliseconds: 10000 # 熔断后休眠时长，默认值5秒<br>   requestVolumeThreshold: 10 # 熔断触发最小请求次数，默认值是20<br>  execution:<br>   isolation:<br>    thread:<br>     timeoutInMilliseconds: 2000 # 熔断超时设置，默认为1秒</p><h2 id="4，Feign伪装请求"><a href="#4，Feign伪装请求" class="headerlink" title="4，Feign伪装请求"></a>4，Feign伪装请求</h2><p>feign是声明式的web service客户端，它让微服务之间的调用变得更简单了，类似controller调用service。Spring Cloud集成了Ribbon和Eureka，可在使用Feign时提供负载均衡的http客户端。</p><p>Feign原理简述</p><p>启动时，程序会进行包扫描，扫描所有包下所有@FeignClient注解的类，并将这些类注入到spring的IOC容器中。当定义的Feign中的接口被调用时，通过JDK的动态代理来生成RequestTemplate。<br>RequestTemplate中包含请求的所有信息，如请求参数，请求URL等。<br>RequestTemplate声场Request，然后将Request交给client处理，这个client默认是JDK的HTTPUrlConnection，也可以是OKhttp、Apache的HTTPClient等。<br>最后client封装成LoadBaLanceClient，结合ribbon负载均衡地发起调用。<br>1，引入Feign</p><p>引入依赖后进行yaml配置：</p><p>server:<br>  port: 8082</p><p>#配置eureka<br>eureka:<br>  client:<br>    service-url:<br>      defaultZone: <a href="http://localhost:8761/eureka">http://localhost:8761/eureka</a><br>  instance:<br>    status-page-url-path: /info<br>    health-check-url-path: /health</p><p>#服务名称<br>spring:<br>  application:<br>    name: product<br>  profiles:<br>    active: ${boot.profile:dev}<br>#feign的配置，连接超时及读取超时配置<br>feign:<br>  client:<br>    config:<br>      default:<br>        connectTimeout: 5000<br>        readTimeout: 5000<br>        loggerLevel: basic<br>2，Feign的使用</p><p>@FeignClient(value = “CART”)<br>public interface CartFeignClient {</p><pre><code>@PostMapping(&quot;/cart/&#123;productId&#125;&quot;)Long addCart(@PathVariable(&quot;productId&quot;)Long productId);</code></pre><p>}<br>上面是最简单的feign client的使用，声明完为feign client后，其他spring管理的类，如service就可以直接注入使用了，例如：</p><p>//这里直接注入feign client<br>@Autowired<br>private CartFeignClient cartFeignClient;</p><p>@PostMapping(“/toCart/{productId}”)<br>public ResponseEntity addCart(@PathVariable(“productId”) Long productId){<br>    Long result = cartFeignClient.addCart(productId);<br>    return ResponseEntity.ok(result);<br>}<br>可以看到，使用feign之后，我们调用eureka 注册的其他服务，在代码中就像各个service之间相互调用那么简单。</p><p>FeignClient注解的一些属性</p><p>属性名    默认值    作用    备注<br>value    空字符串    调用服务名称，和name属性相同<br>serviceId    空字符串    服务id，作用和name属性相同    已过期<br>name    空字符串    调用服务名称，和value属性相同<br>url    空字符串    全路径地址或hostname，http或https可选<br>decode404    false    配置响应状态码为404时是否应该抛出FeignExceptions<br>configuration    {}    自定义当前feign client的一些配置    参考FeignClientsConfiguration<br>fallback    void.class    熔断机制，调用失败时，走的一些回退方法，可以用来抛出异常或给出默认返回数据。    底层依赖hystrix，启动类要加上@EnableHystrix<br>path    空字符串    自动给所有方法的requestMapping前加上前缀，类似与controller类上的requestMapping<br>primary    true    </p><p>此外，还有qualifier及fallbackFactory，这里就不再赘述。</p><p>Feign自定义处理返回的异常</p><p>这里贴上GitHub上openFeign的wiki给出的自定义errorDecoder例子。</p><p>public class StashErrorDecoder implements ErrorDecoder {</p><pre><code>@Overridepublic Exception decode(String methodKey, Response response) &#123;    if (response.status() &gt;= 400 &amp;&amp; response.status() &lt;= 499) &#123;        //这里是给出的自定义异常        return new StashClientException(                response.status(),                response.reason()        );    &#125;    if (response.status() &gt;= 500 &amp;&amp; response.status() &lt;= 599) &#123;        //这里是给出的自定义异常        return new StashServerException(                response.status(),                response.reason()        );    &#125;    //这里是其他状态码处理方法    return errorStatus(methodKey, response);&#125;</code></pre><p>}<br>自定义好异常处理类后，要在@Configuration修饰的配置类中声明此类。</p><p>Feign使用OKhttp发送request</p><p>Feign底层默认是使用jdk中的HttpURLConnection发送HTTP请求，feign也提供了OKhttp来发送请求，具体配置如下：</p><p>feign:<br>  client:<br>    config:<br>      default:<br>        connectTimeout: 5000<br>        readTimeout: 5000<br>        loggerLevel: basic<br>  okhttp:<br>    enabled: true<br>  hystrix:<br>    enabled: true<br>Dubbo学习<br>Dubbo概述<br>Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。<br>阿里11年giuhub–14年dubbo2.4–当当dubbox、网易dubbok—17年SpringCloud出现—阿里18年把dubbox和dubbo合并dubbo2.6<br>2018.02.15 阿里把Dubbo开源给了Apache；<br>2011年，阿里宣布开源SOA服务化治理方案核心框架—Dubbo2.0.7；<br>2014年，当当网Fork一个分支，支持HttpRest协议，命名-Dubbox2.8.0；<br>2014年10月，阿里发布2.3.11。后来就有了SpringCloud；<br>2017年9月，阿里重启Dubbo，发布2.5.4、2.5.5；<br>2018年2月，捐赠Apache基金会，社区生态完善；7月官网Dubbo.apache.org，新logo</p><p> register注册       subscribe订阅           notify通知             invoke调用               count统计</p><p>                                 </p><p>注册中心Register     推荐Zookeeper（修改zoo.cfg），注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者<br>服务提供者Provider<br>暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p><p>服务消费者Consumer    调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。<br>容器Container    服务运行容器<br>监控中心Monitor<br>监控中心dubbo-monitor-simple 负责统计各服务调用次数，调用时间等，统计先在内存汇总后，每分钟一次发送到监控中心服务器，并以报表展示总结，为服务的运维采集数据。<br>可视化后台 dubbo-admin，jar包形式运行（2.5之前war包）。</p><p>二者都是针对特定的注册中心进行监控，因此需要配置对应的注册中心的地址，dubbo.properties或applications.properties。</p><p>Dubbo配置步骤<br>服务提供者注册到注册中心（暴露服务）<br>1、引入dubbo<br>        <dependency><br>            <groupId>com.alibaba</groupId><br>            <artifactId>dubbo</artifactId><br>            <version>2.6.2</version><br>        </dependency><br>//由于我们使用zookeeper作为注册中心，所以需要操作zookeeperdubbo<br>2.6前引入zkclient,dubbo 2.6后curator操作zookeeper;2选1即可–&gt;<br>        <dependency><br>            <groupId>com.101tec</groupId><br>            <artifactId>zkclient</artifactId><br>            <version>0.10</version><br>        </dependency></p><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;        &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;        &lt;version&gt;2.12.0&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>2、配置提供者</p><!--当前应用的名字  --><pre><code>&lt;dubbo:application name=&quot;gmall-user&quot;&gt;&lt;/dubbo:application&gt;</code></pre><!--指定注册中心的地址  --><pre><code>&lt;dubbo:registry address=&quot;zookeeper://118.24.44.169:2181&quot; /&gt;</code></pre><!--使用dubbo协议，将服务暴露在20880端口  --><pre><code>&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;</code></pre><!-- 指定需要暴露的服务 --><pre><code>&lt;dubbo:service interface=&quot;com.atguigu.gmall.service.UserService&quot; ref=&quot;userServiceImpl&quot; /&gt;</code></pre><p>3、启动服务<br>    public static void main(String[] args) throws IOException {<br>        ClassPathXmlApplicationContext context =<br>                new ClassPathXmlApplicationContext(“classpath:spring-beans.xml”);<br>        System.in.read();<br>    }<br>服务消费者去服务中心订阅服务<br>1、引入dubbo<br>        <dependency><br>            <groupId>com.alibaba</groupId><br>            <artifactId>dubbo</artifactId><br>            <version>2.6.2</version><br>        </dependency></p><!-- 由于我们使用zookeeper作为注册中心，所以需要引入zkclient和curator操作zookeeper --><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;com.101tec&lt;/groupId&gt;        &lt;artifactId&gt;zkclient&lt;/artifactId&gt;        &lt;version&gt;0.10&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;        &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;        &lt;version&gt;2.12.0&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>2、配置消费者信息</p><!-- 应用名 --><pre><code>&lt;dubbo:application name=&quot;gmall-order-web&quot;&gt;&lt;/dubbo:application&gt;</code></pre><!-- 指定注册中心地址 --><pre><code>&lt;dubbo:registry address=&quot;zookeeper://118.24.44.169:2181&quot; /&gt;</code></pre><!-- 生成远程服务代理，可以和本地bean一样使用demoService --><pre><code>&lt;dubbo:reference id=&quot;userService&quot; interface=&quot;com.atguigu.gmall.service.UserService&quot;&gt;</code></pre><p></dubbo:reference><br>注解标记</p><p>1、服务提供方<br>&lt;dubbo:application name=”gmall-user”&gt;</dubbo:application><br>&lt;dubbo:registry address=”zookeeper://118.24.44.169:2181” /&gt;<br>&lt;dubbo:protocol name=”dubbo” port=”20880” /&gt;<br>&lt;dubbo:annotation package=”com.atguigu.gmall.user.impl”/&gt;<br>import com.alibaba.dubbo.config.annotation.Service;<br>import com.atguigu.gmall.bean.UserAddress;<br>import com.atguigu.gmall.service.UserService;<br>import com.atguigu.gmall.user.mapper.UserAddressMapper;</p><p>@Service //使用dubbo提供的service注解，注册暴露服务<br>public class UserServiceImpl implements UserService {<br>    @Autowired<br>    UserAddressMapper userAddressMapper；</p><p>2、服务消费方<br>&lt;dubbo:application name=”gmall-order-web”&gt;</dubbo:application><br>&lt;dubbo:registry address=”zookeeper://118.24.44.169:2181” /&gt;<br>&lt;dubbo:annotation package=”com.atguigu.gmall.order.controller”/&gt;</p><p>@Controller<br>public class OrderController {<br>    @Reference  //使用dubbo提供的reference注解引用远程服务<br>    UserService userService;<br>Zookeeper服务注册<br>Xshell rz上传到linux服务器。tar -zxvf 解压后新建data文件夹 然后把zoo-simple.cfg 文件cp一份修改 dataDir为自己创建的目录</p><p>进入Zookeeper的bin目录，启动服务命令<br>./zkServer.sh start</p><p>停止服务命令<br>./zkServer.sh stop</p><p>查看服务状态：<br>./zkServer.sh status</p><p>服务提供方：注意使用Dubbo提供的Service注解，对外发布服务。applicationContext-service.xml配置如下</p><?xml version="1.0" encoding="UTF-8"?><p><beans xmlns="http://www.springframework.org/schema/beans"        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"        xmlns:p="http://www.springframework.org/schema/p"        xmlns:context="http://www.springframework.org/schema/context"        xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"        xmlns:mvc="http://www.springframework.org/schema/mvc"        xsi:schemaLocation="http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd         http://www.springframework.org/schema/mvc         http://www.springframework.org/schema/mvc/spring-mvc.xsd         http://code.alibabatech.com/schema/dubbo         http://code.alibabatech.com/schema/dubbo/dubbo.xsd         http://www.springframework.org/schema/context         http://www.springframework.org/schema/context/spring-context.xsd"><br>    <!-- 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样 --><br>    &lt;dubbo:application name=”dubbodemo_provider” /&gt;<br>    <!-- 连接服务注册中心zookeeper ip为zookeeper所在服务器的ip地址--><br>    &lt;dubbo:registry address=”zookeeper://ip:2181”/&gt;<br>    <!-- 注册  协议和port   端口默认是20880 --><br>    &lt;dubbo:protocol name=”dubbo” port=”20881”&gt;</dubbo:protocol><br>    <!-- 扫描指定包，加入@Service注解的类会被发布为服务  --><br>    &lt;dubbo:annotation package=”com.leo.service.impl” /&gt;<br></beans><br>服务消费方：Controller中注入HelloService使用的是Dubbo提供的@Reference注解 </p><?xml version="1.0" encoding="UTF-8"?><p><beans xmlns="http://www.springframework.org/schema/beans"    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    xmlns:p="http://www.springframework.org/schema/p"    xmlns:context="http://www.springframework.org/schema/context"    xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"    xmlns:mvc="http://www.springframework.org/schema/mvc"    xsi:schemaLocation="http://www.springframework.org/schema/beans            http://www.springframework.org/schema/beans/spring-beans.xsd            http://www.springframework.org/schema/mvc            http://www.springframework.org/schema/mvc/spring-mvc.xsd            http://code.alibabatech.com/schema/dubbo            http://code.alibabatech.com/schema/dubbo/dubbo.xsd            http://www.springframework.org/schema/context            http://www.springframework.org/schema/context/spring-context.xsd"></p><pre><code>&lt;!-- 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样 --&gt;&lt;dubbo:application name=&quot;dubbodemo-consumer&quot; /&gt;&lt;!-- 连接服务注册中心zookeeper ip为zookeeper所在服务器的ip地址--&gt;&lt;dubbo:registry address=&quot;zookeeper://ip:2181&quot;/&gt;&lt;!-- 扫描的方式暴露接口  --&gt;&lt;dubbo:annotation package=&quot;com.leo.controller&quot; /&gt;</code></pre></beans>Dubbo配置说明包扫描<dubbo:annotation package="com.leo.service" /> 提供者和消费者都需要配置。也可通过配置的方式，但是一个配置项(dubbo:service、dubbo:reference)只能发布或者引用一个服务，不太方便。<p>发布服务：<br><bean id="helloService" class="com.itheima.service.impl.HelloServiceImpl" /><br>&lt;dubbo:service interface=”com.itheima.api.HelloService” ref=”helloService” /&gt;</p><p>引用服务：</p><!-- 生成远程服务代理，可以和本地bean一样使用helloService --><p>&lt;dubbo:reference id=”helloService” interface=”com.itheima.api.HelloService” /&gt;<br>协议<br>&lt;dubbo:protocol name=”dubbo” port=”20880”/&gt; 服务提供者处配置，可以指定协议名称和端口号。<br>Dubbo支持协议：dubbo、rmi、hessian、http、webservice、rest、redis等。推荐使用dubbo协议。<br>dubbo 协议: 采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及消费者机器数远大于提供者机器数时。不适合传传文件，传视频等大数据量服务。<br>也可同一个工程中配置多个协议，不同服务使用不同协议：</p><!-- 多协议配置 --><p>&lt;dubbo:protocol name=”dubbo” port=”20880” /&gt;<br>&lt;dubbo:protocol name=”http” port=”1099” /&gt;</p><!-- 使用dubbo协议暴露服务 --><p>&lt;dubbo:service interface=”com.itheima.api.HelloService” ref=”Service1” protocol=”dubbo” /&gt;</p><!-- 使用http协议暴露服务 --><p>&lt;dubbo:service interface=”com.itheima.api.DemoService” ref=”Service2” protocol=”http” /&gt;<br>启动时检查<br>&lt;dubbo:consumer check=”false”/&gt; 配置在消费者处，默认值为true。启动时检查依赖的服务是否可用，不可用抛出异常，阻止 Spring 初始化，排除问题。可以通过将check值改为false来关闭检查。一般开发阶段false，生产环境为true。</p><p>负载均衡</p><p>既可在服务提供者一方配置，也可以在服务消费者一方配置。<br>负载均衡—–将请求分摊到多个操作单元上进行执行，从而共同完成工作任务。均衡策略（包括随机、轮询、最少活跃调用数、一致性Hash），缺省为random随机调用。</p><p>//在服务消费者一方配置负载均衡策略<br>    @Reference(check = false,loadbalance = “random”)<br>//在服务提供者一方配置负载均衡<br>    @Service(loadbalance = “random”)<br>Ps1：开发时候一台机器上启动多个提供者，要修改tomcat、Dubbo服务的端口号防止端口冲突。实际生产环境中，服务提供者是部署在不同的机器上，不存在端口冲突问题。</p><p>Ps2：加入事务注解后@Transactional，Spring会为此类基于JDK动态代理技术创建代理对象，创建的代理对象完整类名为com.sun.proxy.$ProxyXX(35/42等等)，导致Dubbo在进行包匹配时没有成功，发布服务的代码没有执行。</p><p>可以通过修改applicationContext-service.xml配置文件，使用cglib代理方式为Service类创建代理对象<br>&lt;tx:annotation-driven transaction-manager=”transactionManager” proxy-target-class=”true”/&gt;</p><hr><p>1、负载均衡-将请求均衡地分配到多个系统上。常见的技术：</p><p>DNS:一般用来实现地理级别的均衡，耗费IP不适用于做机器级别。</p><p>Nginx-&gt;LVS-&gt;F5:同地点机器级负载均衡。Nginx软件7层，LVS内核4层，F5是硬件4层</p><p>2、负载均衡策略LoadBalance</p><p>Random 随机，按权重设置随机概率。</p><p>RoundRobin 轮循，按公约后的权重设置轮循比率。会产生请求积累问题。</p><p>LeastActive 最少活跃调用数，正在处理请求数（连接数）最少，处理效率高，优先。，</p><p>ConsistentHash一致性Hash，相同参数的请求总是发到同一提供者。</p><p>3、session共享–Session在服务器之间不互通；解决</p><p>session粘滞-将请求都落到同一个服务器上，如Nginx的url hash ；</p><p>session复制-每台服务器都保存一份相同的session；</p><p>session集中存储-数据库或者缓存；</p><p>cookie (主流)-将信息存在加密后的cookie中；</p><p>4，数据库读写分离：</p><p>搭建主从集群，一主一从或一主多从。数据主从复制，主从均包涵全部业务数据。<br>业务服务器将写操作分给数据库主机，将读操作分给数据库从机，<br>     实现方式</p><p>     1、程序代码–代码中抽象一个数据访问层来实现</p><p>     2、中间件—独立一套系统。 MySQL Router、Mycat等</p><p>5、业务分库-按照业务模块将数据分散到不同的数据库服务器。</p><p>join操作问题：业务分库后无法使用一些SQL的关联查询。<br>事务问题：无法通过事务统一修改<br>成本问题：增加更多服务器需求。<br>6、数据分表</p><p>垂直分表：垂直分表适合将表中某些不常用且占了大量空间的列拆分出去。</p><p>水平分表：水平分表适合表行数特别大的表，如单表行&gt;5000万就可以考虑分表。</p><p>水平分表后，使用加路由算法确定数据与表对应关系。</p><p>7、常见的路由算法</p><p>范围路由：用有序数据列为基准。</p><p>Hash路由：用列的值进行Hash运算得Hash结果。</p><p>配置路由：用独立路由表记录路由信息。</p><p>8、微服务通信RPC技术</p><p>Dubbo、Webservice、Hessian、HTTP、RMI等。</p><p>9、微服务治理：</p><p>服务注册与发现 、负载均衡、限流、断融降级</p><p>10、Docker容器</p><p>（1）启动快-是底层进程-秒级，虚拟机进程-分钟。</p><p>（2）资源占用少-不占无用资源；虚拟机占用更多资源。容器还可以共享资源。</p><p>（3）体积小-容器类似轻量级虚拟机，通过小体积提供虚拟化的环境。</p><p>来几个面试题：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;微服务&lt;/strong&gt;——一种软开技术，面向服务SOA架构的一种变体，把程序构造为很多松耦合的服务。&lt;br&gt;&lt;strong&gt;分布式&lt;/strong&gt;——一种部署方式，提高系统稳定性，优化性能。&lt;br&gt;分散部署在不同的机器。是一种面向SOA架构的，服务之间也</summary>
      
    
    
    
    
    <category term="工作记录" scheme="http://tomasonl.github.io/tags/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown语法总结</title>
    <link href="http://tomasonl.github.io/2020/04/30/MarkDown%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://tomasonl.github.io/2020/04/30/MarkDown%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2020-04-30T03:43:33.000Z</published>
    <updated>2020-12-05T01:27:19.183Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MarkDown语法总结"><a href="#MarkDown语法总结" class="headerlink" title="MarkDown语法总结"></a>MarkDown语法总结</h1><h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">斜体：*XXX* &lt;br&gt;</span><br><span class="line">加粗：**XXX**  &lt;br&gt; </span><br><span class="line">斜体加粗： ***XXX***  &lt;br&gt; </span><br><span class="line">删除： ~~XXX~~  &lt;br&gt;</span><br><span class="line">分割线：***    ---</span><br><span class="line">代码 &#96;&#96;&#96;XXX&#96;&#96;&#96;</span><br></pre></td></tr></table></figure><p>斜体：<em>人生啊</em><br>加粗：<strong>茫茫啊</strong><br>斜体加粗： <strong><em>人生啊</em></strong><br>删除： <del>过时不用</del><br>分割线：</p><hr><hr><p>代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An highlighted block</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. AA</span><br><span class="line">2. BBB</span><br><span class="line">3. CCC</span><br><span class="line">- A</span><br><span class="line">- B</span><br><span class="line">- C</span><br></pre></td></tr></table></figure><ol><li>AA</li><li>BBB</li><li>CCC</li></ol><ul><li>A</li><li>B</li><li>C</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">链接: [link](https:&#x2F;&#x2F;www.csdn.net&#x2F;).</span><br><span class="line"></span><br><span class="line">图片: ![Alt](https:&#x2F;&#x2F;imgconvert.csdnimg.cn&#x2F;aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw)</span><br><span class="line"></span><br><span class="line">带尺寸的图片: ![Alt](https:&#x2F;&#x2F;imgconvert.csdnimg.cn&#x2F;aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw &#x3D;30x30)</span><br><span class="line"></span><br><span class="line">居中的图片: ![Alt](https:&#x2F;&#x2F;imgconvert.csdnimg.cn&#x2F;aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center)</span><br><span class="line"></span><br><span class="line">居中并且带尺寸的图片: ![Alt](https:&#x2F;&#x2F;imgconvert.csdnimg.cn&#x2F;aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center &#x3D;30x30)</span><br><span class="line"></span><br><span class="line">超链接： [小狂神MarkDown](https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV12J41137hu?p&#x3D;6)</span><br><span class="line"></span><br><span class="line">&gt; 箭头表示引用或者重要的话！</span><br></pre></td></tr></table></figure><blockquote><p>箭头表示引用或者重要的话！<br><img src="https://img-blog.csdnimg.cn/20200512085528846.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3Njc2NDI5,size_16,color_FFFFFF,t_70" alt="图片"><br>超链接： <a href="https://www.bilibili.com/video/BV12J41137hu?p=6">小狂神MarkDown</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MarkDown语法总结&quot;&gt;&lt;a href=&quot;#MarkDown语法总结&quot; class=&quot;headerlink&quot; title=&quot;MarkDown语法总结&quot;&gt;&lt;/a&gt;MarkDown语法总结&lt;/h1&gt;&lt;h2 id=&quot;文字&quot;&gt;&lt;a href=&quot;#文字&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="工具模块" scheme="http://tomasonl.github.io/tags/%E5%B7%A5%E5%85%B7%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>JAVA多线程</title>
    <link href="http://tomasonl.github.io/2020/04/06/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://tomasonl.github.io/2020/04/06/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-04-05T22:12:39.000Z</published>
    <updated>2020-12-05T01:27:19.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1，线程和进程"><a href="#1，线程和进程" class="headerlink" title="1，线程和进程"></a>1，线程和进程</h2><p>   一个进程执行过程中可以有多个线程，同类多个线程共享进程的堆和方法区，独享程序计数器、虚拟机栈和本地方法栈。</p><a id="more"></a><p>堆：存放对象实例，几乎所有的对象实例都在这里分配内存。<br>方法区：已被虚拟机加载的(元空间) 类信息、常量、静态变量、编译代码</p><p>虚拟机栈：每个方法被执行同时创建一个栈帧，存储局部变量表、操作栈、动态链接、方法出口等信息 。<br>本地方法栈：本地方法栈则是为虚拟机使用到的Native方法服务。<br>(二者保护线程中的局部变量不被别的线程所访问，so私有的啦）<br>程序计数器：字节码解释器通过改变程序计数器实现流程控制、多线程情况下给线程记录位置（so肯定是私有的啦）。也是唯一不会 OutOfMemoryError 的内存区，生命周期随着线程的而创建和销毁。</p><h2 id="2-上下文切换"><a href="#2-上下文切换" class="headerlink" title="2,上下文切换"></a>2,上下文切换</h2><p>     一个CPU在任意时刻只能被一个线程所使用，为了让每一个线程有效执行就给他们分配了时间片进行轮转。当任务执行完当前时间片在进入下一个时间片之前进行状态保存，以便下次使用加载。这个过程就是上下文切换。（纳秒级，Linux&gt;win）</p><h2 id="3-死锁？如何避免？"><a href="#3-死锁？如何避免？" class="headerlink" title="3,死锁？如何避免？"></a>3,死锁？如何避免？</h2><p>多个线程同时被阻塞，都在等待某个资源被释放。</p><p>public class DeadLockDemo {<br>    private static Object resource1 = new Object();//资源 1<br>    private static Object resource2 = new Object();//资源 2</p><pre><code>public static void main(String[] args) &#123;    new Thread(() -&gt; &#123;    synchronized (resource1) &#123;        System.out.println(Thread.currentThread() + &quot;getresource1&quot;);        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(Thread.currentThread() + &quot;waitingget resource2&quot;);        synchronized (resource2) &#123;            System.out.println(Thread.currentThread() + &quot;getresource2&quot;);            &#125;        &#125;    &#125;, &quot;线程 1&quot;).start();    new Thread(() -&gt; &#123;        synchronized (resource2) &#123;            System.out.println(Thread.currentThread() + &quot;getresource2&quot;);        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(Thread.currentThread() + &quot;waitingget resource1&quot;);        synchronized (resource1) &#123;            System.out.println(Thread.currentThread() + &quot;getresource1&quot;);          &#125;        &#125;    &#125;, &quot;线程 2&quot;).start();&#125;</code></pre><p>}<br>输出结果：</p><p>Thread[线程 1,5,main]get resource1<br>Thread[线程 2,5,main]get resource2<br>Thread[线程 1,5,main]waiting get resource2<br>Thread[线程 2,5,main]waiting get resource1<br>两个线程休眠结束都会开始请求对方资源，线程进入互相等待状态。产生锁的四个条件和避免方式如下：</p><p>互斥：资源在任意时刻只能被一个线程调用。（无法破坏，临界资源有互斥访问的必要性）<br>请求与保持：进程因请求资源阻塞时，不释放现有资源。（一次性申请所有资源）<br>不剥夺：线程获得的资源没用完释放之前不能被剥夺。（申请不到，主动释放自占资源）<br>循环等待：几个进程形成头尾相接的循环等待。（按序申请）</p><h2 id="4，sleep（）和wait（）的区别和共同点？"><a href="#4，sleep（）和wait（）的区别和共同点？" class="headerlink" title="4，sleep（）和wait（）的区别和共同点？"></a>4，sleep（）和wait（）的区别和共同点？</h2><p>都可以暂停线程，Thread类的方法：sleep(),yield()等Object的方法：wait()和notify()等<br>sleep没有释放锁，暂停执行。wait释放了锁，用于线程间交互。wait不会自动苏醒，需要别的线程调用同一个对象的notify或者notifyall方法。sleep传入参数自动唤醒。<br>[      为什么wait、notify和notifyAll方法要和synchronized关键字一起使用?因为wait方法使一个线程进入等待状态，并释放其所持有的锁对象，notify方法是通知等待该锁对象的线程重新获得锁对象。所以前提是获得锁对象。锁对象就像一个传话的人，他对某个线程说停下来等待，然后对另一个线程说你可以执行了（实质上是被捕获了），这一过程是线程通信。sleep方法是让某个线程暂停运行一段时间，其控制范围是由当前线程决定，运行的主动权是由当前线程来控制（拥有CPU的执行权）]。<br>sleep是你困了，要睡觉，等你睡醒了再干活。<br>wait是你现在没事做，先眯会儿吧，什么时候领导提醒你该干活了再干。</p><h2 id="5，start（）和run（）方法？"><a href="#5，start（）和run（）方法？" class="headerlink" title="5，start（）和run（）方法？"></a>5，start（）和run（）方法？</h2><p>       新建(new)一个Thread线程，调用start()启动线程进入就绪状态，分配到时间片就运行。start()执行线程相应准备工作然后自动执行run()的内容。 单独直接run()的话就是Thread里面的一个普通方法而已。</p><h2 id="6，synchronized关键字"><a href="#6，synchronized关键字" class="headerlink" title="6，synchronized关键字"></a>6，synchronized关键字</h2><p>    解决的是多个线程间访问资源的同步性。被其修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><p>    修饰实例方法:作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁。<br>    修饰静态方法:也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态synchronized方法，而线程B需要调用这个实例对象所属类的静态 synchronized方法，是允许的，不会发生互斥现象，因为访问静态 synchronized方法占用的锁是当前类的锁，而访问非静态 synchronized方法占用的锁是当前实例对象锁。<br>    修饰代码块:指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</p><p>    总结: synchronized关键字加到 static静态方法和 synchronized（ class）代码块上都是是给Cass类上锁。 synchronized关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized（ string a）因为VM中，字符串常量池具有缓存功能。</p><h2 id="7，说说JDK16之后的-synchronized关键字底层做了哪些优化？"><a href="#7，说说JDK16之后的-synchronized关键字底层做了哪些优化？" class="headerlink" title="7，说说JDK16之后的 synchronized关键字底层做了哪些优化？"></a>7，说说JDK16之后的 synchronized关键字底层做了哪些优化？</h2><p>         jDK1.6锁的实现引入了，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p><p>锁主要存在四种状态，依次是:无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，随着竞争激烈而逐渐升级。但是不可降级，这种策略是为了提髙获得锁和释放锁的效率。</p><h2 id="8，synchronized关键字和-volatile关键字的区别"><a href="#8，synchronized关键字和-volatile关键字的区别" class="headerlink" title="8，synchronized关键字和 volatile关键字的区别"></a>8，synchronized关键字和 volatile关键字的区别</h2><p>      volatile关键字是线程同步的轻量级实现，性能稍微好些。但 volatile只修饰变量。<br>      synchronized关键字后来引入的偏向锁和轻量级锁等优化方式提升了效率，实际开发场景还是较多。<br>      volatile多线程访问 不会发生阻塞，而 synchronized关键字可能会发生阻塞。<br>      volatile保证数据可见性，但不保证原子性。synchronized关键字两者都能保证。<br>      volatile主要用于解决变量在多个线程之间的可见性，而 synchronized解决的是多个线程之间访问资源的同步性。<br>————————————————<br>版权声明：本文为CSDN博主「Leo秋实先生」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/m0_37676429/article/details/105356634">https://blog.csdn.net/m0_37676429/article/details/105356634</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1，线程和进程&quot;&gt;&lt;a href=&quot;#1，线程和进程&quot; class=&quot;headerlink&quot; title=&quot;1，线程和进程&quot;&gt;&lt;/a&gt;1，线程和进程&lt;/h2&gt;&lt;p&gt;   一个进程执行过程中可以有多个线程，同类多个线程共享进程的堆和方法区，独享程序计数器、虚拟机栈和本地方法栈。&lt;/p&gt;</summary>
    
    
    
    
    <category term="工作记录" scheme="http://tomasonl.github.io/tags/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>个人简历</title>
    <link href="http://tomasonl.github.io/2020/03/01/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/"/>
    <id>http://tomasonl.github.io/2020/03/01/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/</id>
    <published>2020-03-01T14:09:47.000Z</published>
    <updated>2020-12-05T01:27:18.835Z</updated>
    
    <content type="html"><![CDATA[<p>凡是不能击败我们的，最终都会让我们更强！</p><a id="more"></a><h1 id="个人基本信息"><a href="#个人基本信息" class="headerlink" title="个人基本信息"></a>个人基本信息</h1><ul><li>李秋实 / 男 / 25 / 硕士</li><li>工作年限：2年</li><li>Email：<a href="mailto:&#116;&#x6f;&#x6d;&#97;&#x73;&#111;&#110;&#108;&#64;&#49;&#54;&#x33;&#x2e;&#99;&#x6f;&#x6d;">&#116;&#x6f;&#x6d;&#97;&#x73;&#111;&#110;&#108;&#64;&#49;&#54;&#x33;&#x2e;&#99;&#x6f;&#x6d;</a> </li><li>QQ/微信号：tomasonl</li><li>Github：<a href="http://github.com/tomasonl">http://github.com/tomasonl</a></li><li>期望职位：Java开发工程师，应用架构师</li><li>期望城市：北京、杭州</li></ul><h1 id="实习经历"><a href="#实习经历" class="headerlink" title="实习经历"></a>实习经历</h1><h2 id="★-浙江省农信联合社-后端开发-2020-07–至今"><a href="#★-浙江省农信联合社-后端开发-2020-07–至今" class="headerlink" title="★ 浙江省农信联合社 后端开发 2020.07–至今"></a>★ 浙江省农信联合社 后端开发 2020.07–至今</h2><h3 id="工作描述："><a href="#工作描述：" class="headerlink" title="工作描述："></a>工作描述：</h3><p>1.参与公司丰收互联APP校园云模块开发，自动化压测，需求规划文档整理。<br>2.参与建设校园金融云后管云平台建设开发，负责与多平台交互查询等相关工作。</p><h2 id="★-睿品智能科技有限公司-后端开发-2019-08–2020-02"><a href="#★-睿品智能科技有限公司-后端开发-2019-08–2020-02" class="headerlink" title="★ 睿品智能科技有限公司 后端开发 2019.08–2020.02"></a>★ 睿品智能科技有限公司 后端开发 2019.08–2020.02</h2><h3 id="工作描述：-1"><a href="#工作描述：-1" class="headerlink" title="工作描述："></a>工作描述：</h3><p>1.参与公司智能消防项目开发，平台分安卓、Unity和Web端，负责后端接口维护与开发。&lt;<br>2.维保模块、巡检模块开发，根据需求进行数据库表结构设计等。</p><h2 id="★-沈阳凡得科技有限公司-软件开发-2019-01-2019-06"><a href="#★-沈阳凡得科技有限公司-软件开发-2019-01-2019-06" class="headerlink" title="★ 沈阳凡得科技有限公司 软件开发 2019.01-2019.06"></a>★ 沈阳凡得科技有限公司 软件开发 2019.01-2019.06</h2><h2 id="工作描述：-2"><a href="#工作描述：-2" class="headerlink" title="工作描述："></a>工作描述：</h2><p>1.参与辽宁某高校教育教学平台等项目开发，主要负责后端代码及平台测试。<br>2.参与数据库设计、通过培训和日常学习对项目开发有了灵活的思维过程。</p><h2 id="★-东北制药集团-数据分析-2018-06–2018-12"><a href="#★-东北制药集团-数据分析-2018-06–2018-12" class="headerlink" title="★ 东北制药集团 数据分析 2018.06–2018.12"></a>★ 东北制药集团 数据分析 2018.06–2018.12</h2><h3 id="工作描述：-3"><a href="#工作描述：-3" class="headerlink" title="工作描述："></a>工作描述：</h3><p>1.东北制药103产线优化项目，Odoo平台模块构建，网站前端页面设计。<br>2.公司信息展示平台Python（Django），linux常用操作，了解学习项目流程。</p><h1 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h1><h2 id="2019-10-2020-01-项目-智慧消防云平台火灾报警系统-后端开发"><a href="#2019-10-2020-01-项目-智慧消防云平台火灾报警系统-后端开发" class="headerlink" title="2019.10 - 2020.01 项目 | 智慧消防云平台火灾报警系统 后端开发"></a>2019.10 - 2020.01 项目 | 智慧消防云平台火灾报警系统 后端开发</h2><p>开发环境：IDEA、MySQL、Redis、Springboot、Shiro权限框架。<br>项目描述：高铁、地铁车站等安消场所智能告警隐患排除平台。<br>技术描述：权限管理使用Apache的Shiro安全框架，对车站角色进行细分。对站点建模收集不同节点传感器信息，实时大屏显示故障、维保以及隐患信息等。</p><h2 id="2019-03-2019-06-项目-辽宁省某特教师专教育教学平台-后端开发"><a href="#2019-03-2019-06-项目-辽宁省某特教师专教育教学平台-后端开发" class="headerlink" title="2019.03 - 2019.06 项目 |  辽宁省某特教师专教育教学平台 后端开发"></a>2019.03 - 2019.06 项目 |  辽宁省某特教师专教育教学平台 后端开发</h2><p>开发环境：IDEA、MySQL、Maven、Tomcat8.0<br>项目描述：完整的前后台综合管理平台。用户权限判断、基础信息管理、培训管理、考勤、宿舍管理、课堂组卷等模块开发检索等功能。<br>技术描述：使用AJAX技术实现局部刷新、COOKIE和SESSION存储、平台采用MVC设计模式，SSM项目框架开发，期间跟前辈学习新技术新知识。个人负责平台学生教师信息模块、学生信息模块、组卷组题模块开发。</p><h2 id="2018-01-2019-01-项目-分布式多传感器多目标边防立体预警系统-算法优化"><a href="#2018-01-2019-01-项目-分布式多传感器多目标边防立体预警系统-算法优化" class="headerlink" title="2018.01 - 2019.01 项目 |  分布式多传感器多目标边防立体预警系统 算法优化"></a>2018.01 - 2019.01 项目 |  分布式多传感器多目标边防立体预警系统 算法优化</h2><p>项目描述：国家级安防科研重点实验项目，电子信息实验室重点项目。<br><br>技术描述：多传感器信息的预处理、目标特征提取、融合，实时传送信息分析系统，融合可见光传感器、红外传感器、车载雷达、激光测距雷达、敌我识别器等信息；本人项目中完成了对TLD目标识别算法进行合理优化，加入惯性效果评价因子，提高算法准确性、稳定性,并发表相关学术论文。</p><h1 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h1><p>● Java语言基础扎实，熟悉Java项目开发流程，语言特性；<br>● 了解SSM、Springboot 等常用项目开发框架，代码习惯良好；<br>● 熟悉Html、CSS、JS 、Ajax等前端技术及 Bootstrap、EasyUI 等前端框架；<br>● 熟悉MySQL数据库、Redis以及Maven、Gradle等项目管理工具；<br>● 熟悉Linux常用指令，熟练使用SVN、Git等版本控制协同开发工具;<br>● 英语六级、新生校长奖学金、国家三等奖学金，校优秀团干部；</p><h2 id="期待有机会能和您这么优秀的团队共事"><a href="#期待有机会能和您这么优秀的团队共事" class="headerlink" title="期待有机会能和您这么优秀的团队共事!"></a>期待有机会能和您这么优秀的团队共事!</h2><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1584250290822&di=0f7ca8066c95a7748289cac348c99db1&imgtype=0&src=http%3A%2F%2Fku.90sjimg.com%2Felement_origin_min_pic%2F00%2F92%2F56%2F0656f228207555b.jpg" width="30" height="30" align=left> <a href="/download/LiXiangResume.pdf">您也可以点击此处下载简历附件</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;凡是不能击败我们的，最终都会让我们更强！&lt;/p&gt;</summary>
    
    
    
    
    <category term="简历中心" scheme="http://tomasonl.github.io/tags/%E7%AE%80%E5%8E%86%E4%B8%AD%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>数据结构和算法01</title>
    <link href="http://tomasonl.github.io/2020/02/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    <id>http://tomasonl.github.io/2020/02/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</id>
    <published>2020-02-28T08:18:51.000Z</published>
    <updated>2020-12-05T01:27:18.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><p>时间复杂度（time complexity）：估算程序指令的执行次数（执行时间）<br>空间复杂度（space complexity）：估算所需占用的存储空间</p><a id="more"></a><h2 id="数据结构和算法的重要性"><a href="#数据结构和算法的重要性" class="headerlink" title="数据结构和算法的重要性"></a>数据结构和算法的重要性</h2><p>算法</p><ol><li>算法是程序的灵魂，即使数据繁杂好的算法依然可以让程序保持高速运转！！！</li><li>算法是程序使用了的内存计算框架(比如 Spark)和缓存技术(比如 Redis 等)等的核心，可以用来优化程序。</li></ol><p>经典语段：<br>       如果说 Java 是自动档轿车，C 就是手动档吉普。数据结构呢？是变速箱的工作原理。<br>你可以不知道变速箱怎样工作，就能开车，而且未必就比懂得的人慢。写程序类似，经验可以起到很大作用，但如果你不知道底层是怎么工作的，就永远只能开车，既不会修车，也不能造车。</p><p>数据结构和算法的关系</p><ol><li>数据结构 (data structure)是一门 研究组织数据方式的学科，可以提高代码效率等。</li><li>数据结构是算法的基础, 程序 = 数据结构 +  算法</li></ol><p>线性结构和非线性结构<br>数据结构包括：线性结构和非线性结构。</p><p>线性结构</p><ol><li>线性结构作为最常用的数据结构，其特点是 数据元素之间是 一对一 的线性关系。</li><li>线性结构有两种不同的存储结构，即 顺序存储结构( 数组)和 链式存储结构( 链表)。</li><li>线性结构常见的有： 数组、队列、链表和栈。。。</li></ol><p>非线性结构<br>非线性结构包括：二维数组，多维数组，广义表，</p><p>稀疏数组：</p><p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p><ol><li>记录数组 一共有几行几列，有多少个不同的值</li><li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而 缩小程序的规模</li></ol><p>队列：</p><ol><li>队列是一个 有序列表，可以用 数组或是 链表来实现。</li><li>遵循 先入先出的原则。<img src="https://img-blog.csdnimg.cn/20190815143112818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3Njc2NDI5,size_16,color_FFFFFF,t_70">冒泡：package com.leo.sort;import java.util.Arrays;public class BubbleSort { public static void main(String[] args) {     int arr[] = {3,9,-1,10,-2};     bubbleSort(arr);     System.out.println(Arrays.toString(arr)); } public static void bubbleSort(int[] arr) {     // 冒泡排序 的时间复杂度 O(n^2), 自己写出     int temp = 0; // 临时变量     boolean flag = false; // 标识变量，表示是否进行过交换     for (int i = 0; i < arr.length - 1; i++) {          for (int j = 0; j < arr.length - 1 - i; j++) {             // 如果前面的数比后面的数大，则交换             if (arr[j] > arr[j + 1]) {                 flag = true;                 temp = arr[j];                 arr[j] = arr[j + 1];                 arr[j + 1] = temp;             }         }         if (!flag) { // 在一趟排序中，一次交换都没有发生过             break;         } else {             flag = false; // 重置flag!!!, 进行下次判断         }     } }}</li></ol><p>Java——Stack详解</p><p><a href="https://www.jianshu.com/p/3587e59948a8">https://www.jianshu.com/p/3587e59948a8</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据结构和算法&quot;&gt;&lt;a href=&quot;#数据结构和算法&quot; class=&quot;headerlink&quot; title=&quot;数据结构和算法&quot;&gt;&lt;/a&gt;数据结构和算法&lt;/h1&gt;&lt;p&gt;时间复杂度（time complexity）：估算程序指令的执行次数（执行时间）&lt;br&gt;空间复杂度（space complexity）：估算所需占用的存储空间&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习历程" scheme="http://tomasonl.github.io/tags/%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>权限管理相关</title>
    <link href="http://tomasonl.github.io/2020/02/28/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>http://tomasonl.github.io/2020/02/28/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</id>
    <published>2020-02-27T22:28:39.000Z</published>
    <updated>2020-12-05T01:27:17.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="权限管理相关"><a href="#权限管理相关" class="headerlink" title="权限管理相关"></a>权限管理相关</h1><h2 id="1-认证和授权？"><a href="#1-认证和授权？" class="headerlink" title="1.认证和授权？"></a>1.认证和授权？</h2><p>   用户身份(Authentication)和用户权限 (Authorization)的区别。</p><a id="more"></a><h2 id="2-Cookie和Session？"><a href="#2-Cookie和Session？" class="headerlink" title="2.Cookie和Session？"></a>2.Cookie和Session？</h2><p>   都是用来跟踪浏览器用户身份的会话方式。Cookie在客户端保存用户信息，会话cookie自动过期setMaxAge设置会话数据存在时间，大小数量和安全问题20个4k以内。Session默认30分钟有效，setMaxInactiveInterval设置或者部署描述符配置有效期。<br>Cookie保存已经登录用户信息，下次访问可自动登录基本信息。(用户个性化设置，主题)……<br>Cookie保存 session或者 token，后端取到就能记录用户当前的状态，因为HTTP协议是无状态的。<br>Cookie记录和分析用户浏览过程。因为HTTP无状态协议，所以将这些信息存放在 Cookie，看你浏览了啥（商品推荐）。<br>通过SessionId实现特定用户登录，一般存放在Redis中。用户登录系统后服务器生产并返回给客户端带有sessionid的cookies，然后用户在此向服务器发起请求的时候就会带着这个Cookies（sessionId），这样后端就知道身份了。<br><a href="https://www.baeldung.com/spring-session">https://www.baeldung.com/spring-session</a>  （springboot的demo跨程序管理）</p><h2 id="3-Token？"><a href="#3-Token？" class="headerlink" title="3.Token？"></a>3.Token？</h2><p>   CSRF跨站请求伪造。就是别人通过cookie拿到你的sessionid就可以代替你的身份访问资源。<br><strong>典型CSRF攻击流程：</strong></p><ul><li>受害者登录a.com，并保留了登录凭证（Cookie）。</li><li>攻击者引诱受害者访问了b.com。</li><li>b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。</li><li>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。</li><li>a.com以受害者的名义执行了act=xx。</li><li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。<br>那么，有没有不用存放session就能认证用户身份呢？Token上场表演。对数据使用算法+密钥进行签名，成为无法伪造的Token。</li></ul><p><strong>基于Token的身份验证JWT：</strong><br>Header：JWT的元数据。定义了生成签名的算法以及Token的类型。<br>Payload：负载、用来存放实际需要传递的数据。<br>Signature：服务器通过Payload/Header和一个密钥（secret）使用Header 中签名算法（默认是HMACSHA256）生成。</p><h2 id="4-SSO与OAuth2-0的区别"><a href="#4-SSO与OAuth2-0的区别" class="headerlink" title="4.SSO与OAuth2.0的区别"></a>4.SSO与OAuth2.0的区别</h2><p>   OAuth2标准授权协议，用来授权第三方应用获取某些权限。SSO(Single Sign On)单点登录 ，解决多个相关的子系统登录一个别的也可以访问。</p><h2 id="5-SpringSecurity"><a href="#5-SpringSecurity" class="headerlink" title="5.SpringSecurity"></a>5.SpringSecurity</h2><p>       <br>提供了可用的安全框架，提供了很多用户认证功能提高开发效率。基于Spring易于集成，有很多封装方法。<br>配置文件较多，RBAC不太明显。对系统中role、user和permission无可操作界面。大数据量下几乎不可以用。</p><h2 id="6-ApacheShiro"><a href="#6-ApacheShiro" class="headerlink" title="6.ApacheShiro"></a>6.ApacheShiro</h2><p>        认证、授权、会话管理和加密。四大基石！<br>subject ：主体 ——-SecurityManager：管家————Realm：安全数据源<br>灵活可用容易集成。自己实现RBAC和操作界面。简单明了！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;权限管理相关&quot;&gt;&lt;a href=&quot;#权限管理相关&quot; class=&quot;headerlink&quot; title=&quot;权限管理相关&quot;&gt;&lt;/a&gt;权限管理相关&lt;/h1&gt;&lt;h2 id=&quot;1-认证和授权？&quot;&gt;&lt;a href=&quot;#1-认证和授权？&quot; class=&quot;headerlink&quot; title=&quot;1.认证和授权？&quot;&gt;&lt;/a&gt;1.认证和授权？&lt;/h2&gt;&lt;p&gt;   用户身份(Authentication)和用户权限 (Authorization)的区别。&lt;/p&gt;</summary>
    
    
    
    
    <category term="工作记录" scheme="http://tomasonl.github.io/tags/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>远离电子毒品</title>
    <link href="http://tomasonl.github.io/2020/02/26/%E8%BF%9C%E7%A6%BB%E7%94%B5%E5%AD%90%E6%AF%92%E5%93%81/"/>
    <id>http://tomasonl.github.io/2020/02/26/%E8%BF%9C%E7%A6%BB%E7%94%B5%E5%AD%90%E6%AF%92%E5%93%81/</id>
    <published>2020-02-26T05:33:46.000Z</published>
    <updated>2020-12-05T01:27:16.805Z</updated>
    
    <content type="html"><![CDATA[<p>你可以旅游，然后你就会拿起手机定酒店看攻略制定计划，发现远的地方不想去近的地方没意思，就此作罢。<br>你可以去看书，你可能觉得出门买纸质书太麻烦选择去当当亚马逊买，但是不知道看什么书于是会逛逛豆瓣知乎，最后发现太麻烦然后下载了一个电子书app看了半天。<br>你可以去学一门乐器<a id="more"></a>比如弹吉他，对着谱捣鼓半天却发现毫无头绪，你苦于没有老师教你会去逛逛贴吧和B站，各种大佬音乐视频看了半天。<br>你可以去找找老朋友聚聚聊天，打电话给他然后发现你的朋友语调迷迷糊糊原来刚刚起床，你们聊了一会微信发现无话可说然后决定一起开黑打游戏。<br>你可以看看新闻，发现电视上的新闻总是按周期准点报送，充斥着与你不太感兴趣的国家基层民生政策与高级领导人的各种会议与活动，决定还是看及时迅速的微博热搜新闻。<br>你可以去学习专业知识，可是坐在桌前不到一会就打瞌睡神游，不知道该怎么办于是来知乎请求大佬答疑解惑贴吧微博找学知识的公众号然而并没啥卵用。<br>天黑了，你点了份外卖吃完洗澡窝在被子里，手机插上充电器，玩到困倦。<br>啊还是玩手机有意思！—————–知乎：16岁的杨先森</p><p>这是一种什么状态<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1584250290822&di=0f7ca8066c95a7748289cac348c99db1&imgtype=0&src=http%3A%2F%2Fku.90sjimg.com%2Felement_origin_min_pic%2F00%2F92%2F56%2F0656f228207555b.jpg" width="30" height="30" align=left><a href="/download/1.pptx">点击此处，下载该课件</a></p><p>　　由于生产力的不断上升，世界上的一大部分人口将不必也无法积极参与产品和服务的生产。为了安慰这些“被遗弃”的人，避免冲突，方法之一就是制造“奶头”、喂之以“奶头”——使令人陶醉的消遺娱乐和充满感官刺激的产品（比如网络、电视和游戏）填满人们的生活、转移其注意力和不满情绪，令其沉浸在“快乐”中不知不觉丧失思考能力、无心挑战现有的统治阶级。</p><p>　　美国旧金山曾于1995年举行过一个集合全球500名经济界、政治界精英的会议，与会者包括萨切尔、老布什、美国有线电视新闻网（CNN）、惠普、Sun微系统的老板等等，该会议的主旨在于为全球化的世界进行分析与规划。会议上，与会者一致认为全球化的高度、快速、激烈的竞争将使全球80%人口”边缘化”，而这80%“边缘化”人口与20%搭上全球化快车的人口之间的冲突将成为今后的主要问题。布热津斯基也及时献计献策，创造了一个新词汇“奶头乐”，英文titty“奶头”与entertainment “娱乐”的组合，一共两种简单的形式第一种是发泄性娱乐，如色情行业、暴力网络、口水战等违反法律和道德的消遣和爱好；第二种是满足性游戏，如肥皂剧、真人秀、短视频等。意指要使彼80%的人安分守己，20%的人高枕无忧，就得采取温情、麻醉、低成本、半满足的办法卸除“边缘化人口”的不满。</p><p>　　想想我们身边的人包括我们自己是否刷抖音和快手的短视频？你想着：“也就是15秒的小视频看看打发一下时间。”但是等你回过神来时，也许早就过了一两个小时。短视频的上瘾除了让我们不自知地丧失时间，也会给我们带来价值观的扭曲。我们是否已经身处娱乐至死的时代而无法抽身，受困于短视频的信息茧房中而不自知？</p><p>　　抖音等短视频应用的出现正是符合了满足性游戏的“奶嘴”形式。当你沉浸在这种短暂和不间断的碎片化娱乐中时 ，你可能会逐渐丧失斗志和创造力。这些搜索成瘾的短视频APP，消耗了你工作之外的时间，甚至干扰你上班的专心程度甚至日常生活。实际上，人性就是喜欢好逸恶劳。抓住了这一致命人性弱点的“奶头乐”正借各种无用的即时反馈产品，钝化人们的思维和上进心。</p><p>你认为不只是你自己耽于享乐，“精英们”也照样在享受人生。其实是你只看到了有钱人的奢华生活，却没有看到他们背后的努力，不否定有些人家庭身世因素，但是这不是我们沉浸与奶头乐的理由。工作是私密枯燥的，真正精英层次的人是不会天天“晒”自己有多努力，多认真的，也不会每天展示自己的成就。</p><p>　　在这个短视频横行、泛娱乐化的时代的我们应该如何自处？明确自己每一个阶段的目标、养成每天思考的习惯是将口中的奶嘴拔出来的第一步。学着打破这种状态</p><p>1，碎片化娱乐时间—-&gt;碎片化学习时间</p><p>　　赶走碎片化娱乐。任何时间不要想着打开手机消磨时光，趴下睡个午觉的话，下午的精力会更加充沛，办事效率会得到提升。远离电子毒品，从电子世界找到丰富自己的东西。有用无用时间占用分辨清晰。</p><p>2，明确,阶段性目标—-&gt;制定计划和自律</p><p>　　庞大的目标会使你倍感压力，但是不要忘了小时候学习的走一步再走一步。将大的目标分解成近期可实现的小目标，及时进行小小的奖励措施，原先遥不可及的目标也许现在会使你干劲满满哦。</p><p>3，养成每天思考的习惯—-&gt;格局决定你走多远</p><p>　　各种无用的诱惑因素都是在挤占了我们大脑的思考时间。我们要学会每天有意识地让自己思考，除了学习计划，思考自己的生活和人生方向，回味一些奋斗过的有趣的历程；或是看一部经典电影，陶醉于音乐，挥洒汗水健身等。</p><p>keep your head up！Focus on real life !</p><p>远离电子毒品,hahaha.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;你可以旅游，然后你就会拿起手机定酒店看攻略制定计划，发现远的地方不想去近的地方没意思，就此作罢。&lt;br&gt;你可以去看书，你可能觉得出门买纸质书太麻烦选择去当当亚马逊买，但是不知道看什么书于是会逛逛豆瓣知乎，最后发现太麻烦然后下载了一个电子书app看了半天。&lt;br&gt;你可以去学一门乐器</summary>
    
    
    
    
    <category term="生活随笔" scheme="http://tomasonl.github.io/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Maven和Grade构建项目</title>
    <link href="http://tomasonl.github.io/2020/02/01/Maven%E5%92%8CGradle%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"/>
    <id>http://tomasonl.github.io/2020/02/01/Maven%E5%92%8CGradle%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/</id>
    <published>2020-02-01T00:26:59.000Z</published>
    <updated>2020-12-05T01:27:19.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Maven介绍"><a href="#一、Maven介绍" class="headerlink" title="一、Maven介绍"></a>一、Maven介绍</h1><h2 id="一、maven介绍"><a href="#一、maven介绍" class="headerlink" title="一、maven介绍"></a>一、maven介绍</h2><p>maven 是一个项目管理工具，主要作用是在项目开发阶段对Java项目进行依赖管理和项目构建。<br>依赖管理：就是对jar包的管理。通过导入maven坐标，就相当于将仓库中的jar包导入了当前项目中。<br>项目构建：通过maven的一个命令就可以完成项目从清理、编译、测试、报告、打包，部署整个过程。</p><p>①maven中央仓库（地址：<a href="http://repo2.maven.org/maven2/%EF%BC%89">http://repo2.maven.org/maven2/）</a><br>②maven私服（公司局域网内的仓库，需要自己搭建）<br>③其他公共远程仓库（例如apache提供的远程仓库，地址：<a href="http://repo.maven.apache.org/maven2/%EF%BC%89">http://repo.maven.apache.org/maven2/）</a></p><p>clean： 清理<br>compile：编译<br>test： 测试<br>package：打包<br>install： 安装</p><h2 id="二、分模块开发"><a href="#二、分模块开发" class="headerlink" title="二、分模块开发"></a>二、分模块开发</h2><p>继承！！！parent！！！</p><p>聚合！！！ module！！！</p><p>Dependencies和dependencyManagement<br>dependencyManagement—–统一管理项目的版本号，确保应用的各个项目的依赖和版本一致，升级版本方便；<br>子项目需要特定版本号时，只需在其dependencies中声明，就可使用自己的不继承父类的。<br>dependencies—–所有声明在dependencies里的依赖都会自动引入，并默认被所有的子项目继承。</p><p>Build标签<br>一种<build>被称为Project Build，即是<project>子元素。另一种<build>被称为Profile Build，即是<profile>的直接子元素。</p><p>Profile Build包含了基本的build元素，而Project Build还包含两个特殊的元素，即各种&lt;…Directory&gt;和<extensions>。</p><p>plugins—用于指定使用的插件；pluginManagement只是用于继承，使得可以在子pom中使用。</p><h1 id="二、Gradle介绍"><a href="#二、Gradle介绍" class="headerlink" title="二、Gradle介绍"></a>二、Gradle介绍</h1><h2 id="一、Gradle介绍-Groove语言"><a href="#一、Gradle介绍-Groove语言" class="headerlink" title="一、Gradle介绍+Groove语言"></a>一、Gradle介绍+Groove语言</h2><p>       Gradle，使用Groovy语言基于Apache Ant和Apache Maven概念的项目自动化构建开源工具。<br>Groovy是一种基于JVM的语言，它结合了Python、Ruby强大的特性，与 Java 代码易结合、扩展。</p><p>2000Ant—2004Maven—2012Gradle</p><p>轻量化趋势，Gradle优点：简化Maven繁琐xml配置、强大支持多工程构建、Groove语言性能。</p><p>语法：</p><p>输出： println “hello，world！”———比较随意，单引号双引号随意，分号可以不加，括号也可以没有。给力！<br>定义变量：def 赋值决定变量—-类似js 也可以强类型定义 int a=666;不过没有基本类型，都是对象类型。<br>lList：def numbers = [1, 2, 3]；Groovy 不支持 Java 数组初始化符号 {}，因为 {} 可能会被曲解成 Groovy 闭包的符号；<br>Map：def colors = [red: ‘#FF0000’, green: ‘#00FF00’, blue: ‘#0000FF’]   <br>闭包：代码块，可以作为参数在方法之间传递。就是定义一个 def m{sout }<br>build.gradle—-局部设置</p><p>settings.gradle—全局设置</p><h2 id="二、Gradle组成"><a href="#二、Gradle组成" class="headerlink" title="二、Gradle组成"></a>二、Gradle组成</h2><ol><li><p>Project与Task<br>在Gradle中，每一个待构建的工程是一个Project，构建一个Project需要执行一系列Task，比如编译、打包这些构建过程的子过程都对应着一个Task。</p></li><li><p>插件<br>插件用来定义和执行Task。</p></li></ol><p>在新建工程的app模块的build.gradle文件的第一行，往往都是如下这句：</p><p>apply plugin: ‘com.android.application’<br>这句话的意思就是应用“com.android.application“这个插件来构建app模块，app模块就是Gradle中的一个Project。也就是说，这个插件负责定义并执行Java源码编译、资源文件编译、打包等一系列Task。实际上”com.android.application”整个插件中定义了如下4个顶级任务：</p><p>assemble: 构建项目的输出（apk）</p><p>check: 进行校验工作</p><p>build: 执行assemble任务与check任务</p><p>clean: 清除项目的输出</p><p>当我们执行一个任务时，会自动执行它所依赖的任务。比如，执行assemble任务会执行assembleDebug任务和assembleRelease任务，这是因为一个Android项目至少要有debug和release这两个版本的输出。</p><ol start="3"><li>Gradle配置文件<br>我们在Android Studio中新建一个工程，可以得到如下的工程结构图：</li></ol><p>上面我们说过，Android Studio中的一个Module即为Gradle中的一个Project。上图的app目录下，存在一个build.gradle文件，代表了app Module的构建脚本，它定义了应用于本模块的构建规则。我们可以看到，工程根目录下也存在一个build.gradle文件，它代表了整个工程的构建，其中定义了适用于这个工程中所有模块的构建规则。</p><p>接下来我们介绍一下上图中其他几个Gradle配置文件：</p><p>gradle.properties: 从它的名字可以看出，这个文件中定义了一系列“属性”。实际上，这个文件中定义了一系列供build.gradle使用的常量，比如keystore的存储路径、keyalias等等。</p><p>gradlew与gradlew.bat: gradlew为Linux下的shell脚本，gradlew.bat是Windows下的批处理文件。gradlew是gradle wrapper的缩写，也就是说它对gradle的命令进行了包装，比如我们进入到指定Module目录并执行“gradlew.bat assemble”即可完成对当前Module的构建（Windows系统下）。</p><p>local.properties: 从名字就可以看出来，这个文件中定义了一些本地属性，比如SDK的路径。</p><p>settings.gradle: 假如我们的项目包含了不只一个Module时，我们想要一次性构建所有Module以完成整个项目的构建，这时我们需要用到这个文件。比如我们的项目包含了ModuleA和ModuleB这两个模块，则这个文件中会包含这样的语句：include ‘:ModuleA’, ‘:ModuleB’。</p><ol start="4"><li>构建脚本<br>首先我们来看一下工程目录下的build.gradle，它指定了真个整个项目的构建规则，它的内容如下：</li></ol><p>buildscript {<br>    repositories {<br>        jcenter() //构建脚本中所依赖的库都在jcenter仓库下载<br>    }<br>    dependencies {<br>        //指定了gradle插件的版本<br>        classpath ‘com.android.tools.build:gradle:1.5.0’<br>    }<br>}</p><p>allprojects {<br>    repositories {<br>        //当前项目所有模块所依赖的库都在jcenter仓库下载<br>        jcenter()<br>    }<br>}</p><p>我们再来简单介绍下app模块的build.gradle的内容：</p><p>//加载用于构建Android项目的插件<br>apply plugin: ‘com.android.application’</p><p>android { //构建Android项目使用的配置<br>    compileSdkVersion 23 //指定编译项目时使用的SDK版本<br>    buildToolsVersion “23.0.1” //指定构建工具的版本</p><p>    defaultConfig {<br>        applicationId “com.absfree.debugframwork” //包名<br>        minSdkVersion 15  //指定支持的最小SDK版本<br>        targetSdkVersion 23 //针对的目标SDK版本<br>        versionCode 1<br>        versionName “1.0”<br>    }<br>    buildTypes { //针对不同的构建版本进行一些设置<br>        release { //对release版本进行的设置<br>            minifyEnabled false //是否开启混淆<br>            proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’  //指定混淆文件的位置<br>        }<br>    }<br>}</p><p>dependencies { //指定当前模块的依赖<br>    compile fileTree(dir: ‘libs’, include: [‘*.jar’])<br>    testCompile ‘junit:junit:4.12’<br>    compile ‘com.android.support:appcompat-v7:23.1.1’<br>    compile ‘com.android.support:design:23.1.1’<br>}</p><h2 id="三、常见配置"><a href="#三、常见配置" class="headerlink" title="三、常见配置"></a>三、常见配置</h2><p>整个工程的build.gradle通常不需我们改动，这里我们介绍下一些对模块目录下build.gradle文件的常见配置。</p><ol><li>依赖第三方库<br>当我们的项目中用到了了一些第三方库时，我们就需要进行一些配置，以保证能正确导入相关依赖。设置方法很简单，比如我们在app模块中中用到了Fresco，只需要在build.gradle文件中的dependencies块添加如下语句：</li></ol><p>dependencies {<br>    …<br>    compile ‘com.facebook.fresco:fresco:0.11.0’<br>}<br>这样一来，Gradle会自动从jcenter仓库下载我们所需的第三方库并导入到项目中。</p><ol start="2"><li>导入本地jar包<br>在使用第三方库时，除了像上面那样从jcenter仓库下载，我们还可以导入本地的jar包。配置方法也很简单，只需要先把jar文件添加到app\libs目录下，然后在相应jar文件上单击右键，选择“Ad As Library”。然后在build.gradle的dependencies块下添加如下语句：</li></ol><p>compile files(‘libs/xxx.jar’)<br>实际上我们可以看到，系统为我们创建的build.gradle中就已经包含了如下语句：</p><p>compile fileTree(dir: ‘libs’, include: [‘*.jar’])<br>这句话的意思是，将libs目录下的所有jar包都导入。所以实际上我们只需要把jar包添加到libs目录下并“Ad As Library”即可。</p><ol start="3"><li>依赖其它模块<br>假设我们的项目包含了多个模块，并且app模块依赖other模块，那么我们只需app\build.gradle的denpendencies块下添加如下语句：</li></ol><p>compile project(‘:other’)<br>4. 构建输出为aar文件<br>通常我们构建的输出目标都是apk文件，但如果我们的当前项目时Android Library，我们的目标输出就是aar文件。要想达到这个目的也很容易，只需要把build.gradle的第一句改为如下：</p><p>apply plugin:’com.android.library’<br>这话表示我们使用的插件不再是构建Android应用的插件，而是构建Android Library的插件，这个插件定义并执行用于构建Android Library的一系列Task。</p><ol start="5"><li>自动移除不再使用的资源<br>只需进行如下配置：</li></ol><p>android {<br>    …<br>    }<br>    buildTypes {<br>        release {<br>            …<br>            shrinkResources true<br>            …<br>        }<br>    }<br>}<br><strong>TIPS：</strong></p><ol><li><p>深入理解Android之Gradle:<a href="http://blog.csdn.net/Innost/article/details/48228651">http://blog.csdn.net/Innost/article/details/48228651</a></p></li><li><p>Gradle构建最佳实践: <a href="http://www.figotan.org/2016/04/01/gradle-on-android-best-practise/">http://www.figotan.org/2016/04/01/gradle-on-android-best-practise/</a></p></li></ol><p>部分结合作者-Bonker 地址-<a href="https://www.cnblogs.com/Bonker/p/5619458.html">https://www.cnblogs.com/Bonker/p/5619458.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Maven介绍&quot;&gt;&lt;a href=&quot;#一、Maven介绍&quot; class=&quot;headerlink&quot; title=&quot;一、Maven介绍&quot;&gt;&lt;/a&gt;一、Maven介绍&lt;/h1&gt;&lt;h2 id=&quot;一、maven介绍&quot;&gt;&lt;a href=&quot;#一、maven介绍&quot; class</summary>
      
    
    
    
    
    <category term="工作记录" scheme="http://tomasonl.github.io/tags/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>生活随笔</title>
    <link href="http://tomasonl.github.io/2020/01/29/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    <id>http://tomasonl.github.io/2020/01/29/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/</id>
    <published>2020-01-29T14:09:47.000Z</published>
    <updated>2020-12-05T01:27:16.690Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在想放弃和懈怠的时候如何去做？"><a href="#在想放弃和懈怠的时候如何去做？" class="headerlink" title="在想放弃和懈怠的时候如何去做？"></a>在想放弃和懈怠的时候如何去做？</h2><ol><li>和各种倦怠症说拜拜<br>为自己找到为什么，找到你愿意争取的事情</li><li>弄明白当下生活的含义<br>最主要的目的是？</li><li>建立习惯，利用习惯的力量<br>把自己想要做的事情变成一种习惯，固定时间点</li></ol><p>努力和后悔？你准备选择哪一个？</p><h1 id="24小时"><a href="#24小时" class="headerlink" title="24小时"></a>24小时</h1><p>How to build?</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;在想放弃和懈怠的时候如何去做？&quot;&gt;&lt;a href=&quot;#在想放弃和懈怠的时候如何去做？&quot; class=&quot;headerlink&quot; title=&quot;在想放弃和懈怠的时候如何去做？&quot;&gt;&lt;/a&gt;在想放弃和懈怠的时候如何去做？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;和各种倦怠症说拜拜&lt;br</summary>
      
    
    
    
    
    <category term="生活随笔" scheme="http://tomasonl.github.io/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>你好，我的朋友！</title>
    <link href="http://tomasonl.github.io/2020/01/01/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%88%91%E7%9A%84%E6%9C%8B%E5%8F%8B/"/>
    <id>http://tomasonl.github.io/2020/01/01/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%88%91%E7%9A%84%E6%9C%8B%E5%8F%8B/</id>
    <published>2020-01-01T10:43:33.000Z</published>
    <updated>2020-12-05T01:27:18.372Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速引导"><a href="#快速引导" class="headerlink" title="快速引导"></a>快速引导</h2><p><strong>Hexo 的基本命令</strong><br>$ hexo clean #清除生成的博客静态文件<br>$ hexo g #生成博客静态文件=命令hexo generate<br>$ hexo s #启动博客的本地预览=命令hexo server<br>$ hexo d #推送博客到远程仓库=命令hexo deploy<br>$ hexo new page xxx #新建名为”xxx”的页面<br>$ hexo new xxx #新建名为”xxx”的文章<br>$ hexo d -g #生成静态博客并推送到Git远程仓库<br>$ hexo s -g #生成静态博客并启动本地预览</p><h3 id="新建一个博客"><a href="#新建一个博客" class="headerlink" title="新建一个博客"></a>新建一个博客</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>友情链接: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>当然，也可以直接发布到github，不用本地启动<br>友情链接: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生产静态文件"><a href="#生产静态文件" class="headerlink" title="生产静态文件"></a>生产静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>友情链接: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="部署到远程仓库"><a href="#部署到远程仓库" class="headerlink" title="部署到远程仓库"></a>部署到远程仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">    github: https:&#x2F;&#x2F;github.com&#x2F;tomasonl&#x2F;tomasonl.github.io.git</span><br><span class="line">    coding: git@e.coding.net:tomasonl&#x2F;tomasonl&#x2F;tomasonl.coding.me.git</span><br><span class="line">    # coding: https:&#x2F;&#x2F;e.coding.net&#x2F;tomasonl&#x2F;tomasonl&#x2F;tomasonl.coding.me.git</span><br><span class="line">    gitee: https:&#x2F;&#x2F;gitee.com&#x2F;tomasonl&#x2F;tomasonl</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>SSH部署或者Http部署地址均可<br>也可以直接Hexo d -g  完成上面两个步骤</p><h2 id="附加功能设置："><a href="#附加功能设置：" class="headerlink" title="附加功能设置："></a><strong>附加功能设置：</strong></h2><h3 id="添加视频"><a href="#添加视频" class="headerlink" title="添加视频"></a>添加视频</h3><p>哔哩哔哩-视频格式如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line"></span><br><span class="line">&lt;div style&#x3D;&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;</span><br><span class="line">    &lt;iframe src&#x3D;&quot;&#x2F;&#x2F;player.bilibili.com&#x2F;player.html?aid&#x3D;93813318&amp;bvid&#x3D;BV18E411x7eT&amp;cid&#x3D;160169443&amp;page&#x3D;22&quot; scrolling&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; frameborder&#x3D;&quot;no&quot; framespacing&#x3D;&quot;0&quot; allowfullscreen&#x3D;&quot;true&quot; style&#x3D;&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt; &lt;&#x2F;iframe&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><h3 id="开启下载"><a href="#开启下载" class="headerlink" title="开启下载"></a><strong>开启下载</strong></h3><p>post_asset_folder: true</p><h3 id="设置文章Cover"><a href="#设置文章Cover" class="headerlink" title="设置文章Cover"></a>设置文章Cover</h3><p>在文章头部设置cover：+链接；</p><p>友情链接: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;快速引导&quot;&gt;&lt;a href=&quot;#快速引导&quot; class=&quot;headerlink&quot; title=&quot;快速引导&quot;&gt;&lt;/a&gt;快速引导&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Hexo 的基本命令&lt;/strong&gt;&lt;br&gt;$ hexo clean #清除生成的博客静态文件&lt;br&gt;$ </summary>
      
    
    
    
    
    <category term="工具模块" scheme="http://tomasonl.github.io/tags/%E5%B7%A5%E5%85%B7%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>日常工作记录总结帖</title>
    <link href="http://tomasonl.github.io/2020/01/01/%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95-Tomasonl/"/>
    <id>http://tomasonl.github.io/2020/01/01/%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95-Tomasonl/</id>
    <published>2020-01-01T00:26:59.000Z</published>
    <updated>2020-12-05T01:27:17.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-生产力工具篇"><a href="#1-生产力工具篇" class="headerlink" title="1. 生产力工具篇"></a>1. 生产力工具篇</h1><h2 id="1-1-IDEA优秀插件必备"><a href="#1-1-IDEA优秀插件必备" class="headerlink" title="1.1. IDEA优秀插件必备"></a>1.1. IDEA优秀插件必备</h2><h2 id="1-2-IDEA快捷键使用"><a href="#1-2-IDEA快捷键使用" class="headerlink" title="1.2. IDEA快捷键使用"></a>1.2. IDEA快捷键使用</h2><h2 id="1-3-HEXO博客相关技术栈"><a href="#1-3-HEXO博客相关技术栈" class="headerlink" title="1.3. HEXO博客相关技术栈"></a>1.3. HEXO博客相关技术栈</h2><h2 id="1-4"><a href="#1-4" class="headerlink" title="1.4."></a>1.4.</h2><h1 id="2-Java后端技术篇"><a href="#2-Java后端技术篇" class="headerlink" title="2. Java后端技术篇"></a>2. Java后端技术篇</h1><h2 id="2-1-，想要在启动SpringBoot时自动运行某接口？"><a href="#2-1-，想要在启动SpringBoot时自动运行某接口？" class="headerlink" title="2.1. ，想要在启动SpringBoot时自动运行某接口？"></a>2.1. ，想要在启动SpringBoot时自动运行某接口？</h2><p>package com.example.controller;<br>import org.springframework.boot.CommandLineRunner;<br>import org.springframework.stereotype.Component;<br>@Component<br>public class Hahah implements CommandLineRunner{<br>@Override<br>public void run(String… args) throws Exception {<br>    System.out.println(“What the fuck!”);<br>}<br>}<br>记得在类上加@Component注解；<br>其实类似“开机启动”，两种：ApplicationRunner和CommandLineRunner。<br>如果想要设定顺序，可以实现org.springframework.core.Ordered接口 或者 @Order(value = X)注解来实现。<br>动态修改定时器任务：<br>1.首先这里我们需要重新认识一个类ThreadPoolTaskScheduler：线程池任务调度类，能够开启线程池进行任务调度。<br>2.ThreadPoolTaskScheduler.schedule()方法会创建一个定时计划ScheduledFuture，在这个方法需要添加两个参数， Runnable（线程接口类） 和CronTrigger（定时任务触发器）<br>3.在ScheduledFuture中有一个cancel可以停止定时任务。</p><h2 id="2-2-定时器任务？嫌麻烦？-Schedule-香不香？哈哈。"><a href="#2-2-定时器任务？嫌麻烦？-Schedule-香不香？哈哈。" class="headerlink" title="2.2. , 定时器任务？嫌麻烦？@Schedule 香不香？哈哈。"></a>2.2. , 定时器任务？嫌麻烦？@Schedule 香不香？哈哈。</h2><p>package com.example.controller;</p><p>import org.springframework.scheduling.annotation.Scheduled;<br>import org.springframework.stereotype.Component;<br>import java.text.SimpleDateFormat;<br>import java.util.Calendar;<br>import java.util.Date;</p><p>@Component<br>public class Hahaha {<br>@Scheduled(cron=”0 0/30 * * * ? “)<br>public void Hello(){<br>SimpleDateFormat format = new SimpleDateFormat(“yyyy年MM月dd日HH时mm分ss秒”);<br>Date date = new Date();<br>System.out.println(“当前时间表示方法A”+format.format(date));<br>Calendar calendar = Calendar.getInstance();<br>System.out.println(“当前时间表示方法B:”+format.format(calendar.getTime()));<br>System.out.println(“又过去了半个小时，你都干了些啥？？？老弟！”);<br>}<br>}</p><h2 id="2-3-，SpringDataJpa插入数据表名有下划线的时候？"><a href="#2-3-，SpringDataJpa插入数据表名有下划线的时候？" class="headerlink" title="2.3. ，SpringDataJpa插入数据表名有下划线的时候？"></a>2.3. ，SpringDataJpa插入数据表名有下划线的时候？</h2><p>据库中的字段名是loginName，实体中应当这样写<br>@Column(name = “loginname”)<br>private String loginName;<br>执行sql语句时，大写的驼峰字符会变成下划线“_”，如果写loginName查询时会变成login_name，所以会报异常:</p><p>Caused by: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Unknown column ‘login_name’ in ‘field list’</p><p>而javabean中要保持大小写格式，否则不能映射成功！！！</p><h2 id="2-4-，mysql在Windows大小写敏感问题"><a href="#2-4-，mysql在Windows大小写敏感问题" class="headerlink" title="2.4. ，mysql在Windows大小写敏感问题"></a>2.4. ，mysql在Windows大小写敏感问题</h2><p><a href="https://www.cnblogs.com/swje/p/6628315.html?utm_source=debugrun&amp;utm_medium=referral">https://www.cnblogs.com/swje/p/6628315.html?utm_source=debugrun&amp;utm_medium=referral</a></p><p>How table and database names are stored on disk and used in MySQL is affected by the lower_case_table_names system variable, which you can set when starting mysqld. lower_case_table_names can take the values shown in the following table. This variable does not affect case sensitivity of trigger identifiers. On Unix, the default value of lower_case_table_names is 0. On Windows, the default value is 1. On OS X, the default value is 2.</p><p>PS：mac OS（2012年前称Mac OS X，2012年-2016年称OS X）</p><h2 id="2-5-，Springboot-同时插入json和file文件时出现如下错误？"><a href="#2-5-，Springboot-同时插入json和file文件时出现如下错误？" class="headerlink" title="2.5. ，Springboot 同时插入json和file文件时出现如下错误？"></a>2.5. ，Springboot 同时插入json和file文件时出现如下错误？</h2><p>{“status”: 415,<br>“error”: “Unsupported Media Type”,<br>“Content type ‘multipart/form-data;boundary=————————429210727736774900703947;charset=UTF-8’ not supported”,<br>}<br>只需要去掉@requestBody注解，为啥再看看。而且平时传参数一般都是写个javabean，没有这个表的模型数据就自己写一个以便于别人知道你传过来的是啥。</p><p>/**</p><ul><li>该方法为XXX</li><li>@param</li><li>@return</li><li>/<br>@RequestMapping(value = “/addMaintainTask”, method = RequestMethod.POST)<br>@ResponseBody<br>public String addMaintainTask(@RequestBody MaintainTaskOptions options, @RequestParam(“file”) MultipartFile file){}<br>|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||<br>@RequestMapping(value = “/addMaintainTask”, method = RequestMethod.POST)<br>@ResponseBody<br>public String addMaintainTask(MaintainTaskOptions options, @RequestParam(“file”) MultipartFile file){}</li></ul><h2 id="2-6-，Json传输时间传输格式？"><a href="#2-6-，Json传输时间传输格式？" class="headerlink" title="2.6. ，Json传输时间传输格式？"></a>2.6. ，Json传输时间传输格式？</h2><p>long类型的时间戳Unix timestamp 使用FASTJSON的JsonObject去接很完美，如果自己写model类的话 时间类型定义匹配然后转date。如果前台传过来String 那就 SimpleDateFormat类的parse(String source)方法和format(Date date)方法。</p><p>Failed to convert property value of type ‘java.lang.String’ to required type ‘java.util.Date’ for property ‘maintainStartTime’; nested exception is org.springframework.core.convert.ConversionFailedException: Failed to convert from type [java.lang.String] to type [java.util.Date] for value ‘1577068194898’; nested exception is java.lang.</p><h2 id="2-7-common-lang3插件？"><a href="#2-7-common-lang3插件？" class="headerlink" title="2.7. , common-lang3插件？"></a>2.7. , common-lang3插件？</h2><p>import org.apache.commons.lang3.StringUtils;<br>/**</p><p>StringUtils常用方法<br>/<br>public class TestStringUtils {<br>public static void main(String[] args) {<br>testReplace();<br>}<br>/**<br>测试IsBlank<br>/<br>public static void testBlank() {<br>String str = “you are luck!”;<br>// 结果为false<br>System.out.println(StringUtils.isBlank(str));<br>// 结果为true<br>System.out.println(StringUtils.isBlank(“”));<br>// 结果为true<br>System.out.println(StringUtils.isBlank(null));<br>//// 对于制表符、换行符、换页符和回车符StringUtils.isBlank()均识为空白符<br>System.out.println(StringUtils.isBlank(“\t \n \f \r”));<br>// true,只要为空白字符都为true<br>System.out.println(StringUtils.isBlank(“ “));<br>// isNotBlank,只要为null或者””都等于false<br>System.out.println(StringUtils.isNotBlank(“”));<br>}<br>/**<br>测试isEmpty 只要不是null和””都为true<br>/<br>public static void testEmpty() {<br>String str = “thanks you”;<br>System.out.println(StringUtils.isEmpty(str));<br>// 空白字符为true<br>System.out.println(StringUtils.isEmpty(“”));<br>// 空格字符为false<br>System.out.println(StringUtils.isEmpty(“ “));<br>// 对于制表符、换行符、换页符和回车符StringUtils.isEmpty()均识不为空<br>System.out.println(StringUtils.isEmpty(“\t \n \f \r”));<br>System.out.println(StringUtils.isEmpty(null));<br>}<br>/**<br>测试equals 只要内容相同，就返回true<br>/<br>public static void testEquals() {<br>String s1 = “hello word”;<br>String s2 = “hello word”;<br>String s3 = new String(“hello word”);<br>System.out.println(StringUtils.equals(s1, s2));<br>System.out.println(StringUtils.equals(s1, s3));<br>}<br>/**<br>测试join 将数组以符号或其他字符串为间隔组成新的字符串<br>/<br>public static void testJoin() {<br>    String[] strs = { “1”, “2”, “3”, “4”, “5”, “6” };<br>    String join = StringUtils.join(strs, “|”);<br>    // 1|2|3|4|5|6<br>    System.out.println(join);<br>}<br>/**</p><ul><li>测试split 把字符串以某个字符分开，返回一个字符串数组</li><li>/<br>public static void testSplit() {<br>   String str = “1|2|3|4|5|6”;<br>   String[] split = StringUtils.split(str, ‘|’);<br>   // 结果为1,2,3,4,5,6<br>   for (String string : split) {<pre><code>   System.out.println(string);</code></pre>   }<br>}<br>/**</li><li>测试TrimToNull 把字符串的开头空格和尾部的空格去掉</li><li>/<br>public static void testTrimToNull() {<br>   String str = “  you are luck  “;<br>   String trimToNull = StringUtils.trimToNull(str);<br>   // “you are luck”<br>   System.out.println(trimToNull);<br>}<br>/**</li><li>测试replace 对字符串，在其中截取某个字符串替换成某个字符串</li><li>/<br>public static void testReplace() {<br>   String str = “you is luck”;<br>   String replace = StringUtils.replace(str, “is”, “are”);<br>   // you is luck<br>   System.out.println(str);<br>   // you are luck<br>   System.out.println(replace);<br>}<br>}<h1 id="3-前端技术篇"><a href="#3-前端技术篇" class="headerlink" title="3. 前端技术篇"></a>3. 前端技术篇</h1></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-生产力工具篇&quot;&gt;&lt;a href=&quot;#1-生产力工具篇&quot; class=&quot;headerlink&quot; title=&quot;1. 生产力工具篇&quot;&gt;&lt;/a&gt;1. 生产力工具篇&lt;/h1&gt;&lt;h2 id=&quot;1-1-IDEA优秀插件必备&quot;&gt;&lt;a href=&quot;#1-1-IDEA优秀插件必</summary>
      
    
    
    
    
    <category term="工作记录" scheme="http://tomasonl.github.io/tags/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
</feed>
